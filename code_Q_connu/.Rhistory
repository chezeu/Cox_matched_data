s[i,] = (Z1R - t3R/t2R)
}
s <- colSums(s)
return(s=s)
}
# ###########solve the equation
coxph_estimate<- function(beta,prob,Ts,event,XB, Q,beta_ini,maxiter = 50){
f <- function(x){
equa_estimate  (beta= x,prob,Ts,event,XB, Q)
}
fit_manual <- nleqslv( c(beta_ini[1],beta_ini[2]),f, method = c("Broyden", "Newton"))
beta0 <- fit_manual$x
iterations <- fit_manual$iter
converge <- as.numeric(( iterations< maxiter)& (fit_manual$scalex==1) )
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
#fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
# beta0 <- fit_manual$root
#iterations <- fit_manual$iter
#converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list( beta0 = beta0, converge = converge, iterations = iterations) )
}
beta_ini=c(0,0)
H_f = coxph_estimate (beta,prob,Ts,event,XB, Q,beta_ini, maxiter = 50)
H_f$beta0
H_f$converge
H_f$iterations
### iterrations ###########################################
#valeurs initials
Func_itteration<-function(beta,beta0,lambda0,Ts,event,XB, Q,tol= 1e-6, maxits = 500){
p = ncol(XB)
n = length(Ts)
it = 0
converge = FALSE
while ((!converge) & (it < maxits)){
lambda0.old = lambda0
beta0.old = beta0
beta_ini = beta0.old
#expectation
lambda2 = Funct_lambda2(lambda0.old,Ts,event)
prob = Functio_prob(beta0.old,lambda0.old,Ts,event,XB, Q)
#maximization
lambda0 = Function_lambda0 (prob,beta0, Ts,event,XB, Q)
estime = coxph_estimate (beta,prob,Ts,event,XB, Q,beta_ini, maxiter = 50)
beta0 = estime$beta0
converge = (sum ((beta0.old -beta0))^2 + sum ( (lambda0.old - lambda0)^2 ) ) < tol
if (it == maxits) {
cat("WARNING! NOT CONVERGENT!", "\n")
converge = FALSE
}else if(is.na(beta0[1]) & is.na(beta0[2])){
cat("WARNING! beta0 NOT AVAILABLE!", "\n")
converge = FALSE
}
it = it + 1
}
return(list(beta0=beta0, lambda0=lambda0, prob=prob, converge= converge))
}
#############################################################
#method 4
p = 2
m    = 300
n    = 250
beta = c(0.5,-0.5)
C = c(0.8,0.1,0.1)
beta_ini=c(0,0)
surv_data = Generate_data(m,n,beta)
mf = Matrix_function(n,m,C,beta,surv_data)
data_true = mf$data_true
data_naive = mf$data_naive
Ts = mf$data_true$Time
event = mf$data_true$delta
Q = mf$Q
XB = mf$XB
Z = as.matrix(data_naive[,3:(p+2)])
lambda0 =  rep(0.1,length(event))
beta0 = c(0.1,0.1)
prob =  Functio_prob(beta0,lambda0,Ts,event,XB, Q)
fit_estimate = Func_itteration(beta,beta0,lambda0,Ts,event,XB, Q,tol= 1e-6, maxits = 500)
coef_estimate = fit_estimate$beta0
lambda0_estimate = fit_estimate$lambda0
converge_estimate = fit_estimate$converge
# Theoretical estimating equation for true and naive data
fit_true = coxph(Surv(Time,delta)~.,data = data_true)
coef_true = as.vector(fit_true$coefficients)
var_true = diag(fit_true$var)
coef_true
coef_estimate
equa_naive <- function(beta,Ts,event, Z) {
p=ncol(Z)
ezbeta = exp(Z%*% beta)
zezbeta = Z*matrix(rep(exp(Z%*% beta),p), ncol = p)
n = length(Ts)
s = 0
for(i in 1:n){
#Yi<- as.numeric( Ts >= Ts[i])# at risk
Yi = as.numeric( (Ts == Ts[i] ) | (Ts > Ts[i]))# at risk
risq = which(Yi==1)
if(length(risq)==1){
num_naive = zezbeta[risq,]
denum_naive = ezbeta[risq]
}else if (length(risq)!=1){
num_naive = colSums( zezbeta[risq,])
denum_naive = sum(ezbeta[risq])  }
s = s+ event[i]* ( Z[i,]- num_naive/denum_naive)
}
s
return(H_naive = s) ##naive estimator
}
# solve the naive equation
coxph_equa_naive <- function(Ts,event, Z, maxiter = 20){
p=ncol(Z)
f <- function(x){
equa_naive (beta=x,Ts,event, Z)
}
fit_manual = multiroot(f,start = rep(0,p), maxiter = maxiter)
beta = fit_manual$root
iterations = fit_manual$iter
converge = as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge, iterations = iterations))
}
p = 2
coxph_equa_naive(Ts, event, Z, maxiter = 20)
# Theoretical estimating equation for true and naive data
fit_true = coxph(Surv(Time,delta)~.,data = data_true)
coef_true = as.vector(fit_true$coefficients)
var_true = diag(fit_true$var)
fit_naive2 = coxph(Surv(Time,delta)~.,data = data_naive)
coef_naive2 = as.vector(fit_naive2$coefficients)
var_naive2 = diag(fit_naive2$var)
fit_naive = coxph_equa_naive(Ts,event, Z, maxiter = 20)
coef_naive = fit_naive$coef
converge_naive = fit_naive$converge
coef_true
coef_naive
coef_naive2
#################
equa_W_sum1 <- function(beta,Ts,event,XB, Q) {
p = ncol(XB)
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
##les sommes pour Z
Z = Q%*%X
## les sommes q*exp(beta x) pour tilfe_f
som1 =  Q%*%eXbeta
##  les sommes pour tilde_g
som2 = Q%*%XeXbeta
dat1 = cbind(Ts,Z)[which(event==1),] #new  data
## Estimating equation
s = matrix(0,nrow=nrow(dat1), ncol = p)
for (i in 1:nrow(dat1)) {
ts = dat1[i, 1]
Z1R = dat1[i,2:ncol(dat1)]
risk = GetRiskSet(ts, Ts, event)
nrisk = length(risk)
if(nrisk==1){
t2R = som1[risk]
t3R = matrix(som2, ncol = p)[risk,]
}else if(nrisk!=1){
t2R = sum(som1[risk] )
t3R = colSums(matrix(som2, ncol = p)[risk,] ) }
s[i,] = (Z1R - (t3R/t2R))
}
s = colSums(s)
return(s=s)
}
# ###########solve the equations
coxph_w_sum1 <- function(Ts,event,XB, Q, maxiter = 20){
f <- function(x){
equa_W_sum1  (beta=x,Ts,event,XB, Q)
}
fit_manual = multiroot(f,start = rep(0,p), maxiter = maxiter)
beta = fit_manual$root
iterations = fit_manual$iter
converge = as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge,iterations = iterations))
}
#############################
#second method
fit_w_sum1 = coxph_w_sum1(Ts,event,XB, Q,maxiter = 20)
coef_w_sum1 = fit_w_sum1$coef
converge_w_sum1 = fit_w_sum1$converge
coef_true
coef_w_sum1
#################
equa_W_sum2 <- function(beta,Ts,event,XB, Q) {
p = ncol(XB)
n = length(Ts)
X = as.matrix(XB, ncol = p) #Only covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
# somme des deux valeurs max
Z = matrix(0, nrow = n, ncol = p)
som1 = vector()                  # denominateur
som2 = matrix(0, nrow = n, ncol = p) #numerateur
for (i in 1:n) {
qi = Q[i,]
i1 = which(qi == max(qi))
l1 = max(qi)
qi[i1] = 0
i2 = which(qi == max(qi))
if(length(i2)!= 1){i2 = i2[1]}
qi[i1] = l1
qix = (qi*X)[c(i1,i2),]
Z[i,] = colSums(qix)
#### les sommes q*exp(beta x) pour tilfe_f
qixbeta = (qi*eXbeta)[c(i1,i2),]
som1[i] = sum( qixbeta)
###  les sommes pour tilde_g
qiXeXbeta = (qi*XeXbeta)[c(i1,i2),]
som2[i,] = colSums(qiXeXbeta)
}
dat1 = cbind(Ts,Z)[which(event==1),]
## Estimating equation
s = matrix(0,nrow=nrow(dat1), ncol = p)
for (i in 1:nrow(dat1)) {
ts = dat1[i, 1]
Z1R = dat1[i,2:ncol(dat1)]
risk = GetRiskSet(ts, Ts, event)
nrisk = length(risk)
if(nrisk==1){
t2R = som1[risk]
t3R = matrix(som2, ncol = p)[risk,]
}else if(nrisk!=1){
t2R = sum(som1[risk] )
t3R = colSums(matrix(som2, ncol = p)[risk,] ) }
s[i,] = (Z1R - (t3R/t2R))
}
s = colSums(s)
return(H_w_sum2 = s)
}
# ###########solve the equations
coxph_w_sum2 <- function(Ts,event,XB, Q, maxiter = 20){
p= ncol(XB)
f <- function(x){
equa_W_sum2  (beta=x,Ts,event,XB, Q)
}
fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
beta <- fit_manual$root
iterations <- fit_manual$iter
converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge, iterations=iterations))
}
#############################
### method 3
fit_w_sum2 = coxph_w_sum2(Ts,event,XB, Q, maxiter = 20)
coef_w_sum2 = fit_w_sum2$coef
converge_w_sum2 = fit_w_sum2$converge
coef_true
coef_w_sum2
################### monte carlos
p = 2
m    = 300
n    = round((80*m)/100)
beta = c(0.5,-0.5)
C = c(0.8,0.1,0.1)
beta_ini=c(0,0)
nsim=3
estimates_survival<- function(nsim,n,m,C,p,beta,Q,lambda0,beta0){
coef_true_s = matrix(0,nrow = nsim, ncol = p)
coef_naive_s = matrix(0,nrow = nsim, ncol = p)
converge_naive = vector()
coef_w_sum1_s = matrix(0,nrow = nsim, ncol = p)
converge_w_sum1 = vector()
coef_w_sum2_s = matrix(0,nrow = nsim, ncol = p)
converge_w_sum2 = vector()
coef_estimate_s = matrix(0,nrow = nsim, ncol = p)
converge_estimate = vector()
for (i in 1:nsim){
surv_data = Generate_data(m,n,beta)
mf = Matrix_function(n,m,C,beta,surv_data)
data_true = mf$data_true
data_naive = mf$data_naive
Ts = mf$data_true$Time
event = mf$data_true$delta
Q = mf$Q
XB = mf$XB
Z = as.matrix(data_naive[,3:(p+2)])
lambda0 =  rep(0.1,length(event))
beta0 = c(0.1,0.1)
prob =  Functio_prob(beta0,lambda0,Ts,event,XB, Q)
# Theoretical estimating equation for true and naive data
fit_true = coxph(Surv(Time,delta)~.,data = data_true)
coef_true_s[i,] = as.vector(fit_true$coefficients)
fit_naive = coxph_equa_naive(Ts,event, Z, maxiter = 20)
coef_naive_s[i,] = fit_naive$coef
converge_naive[i] = fit_naive$converge
fit_w_sum1 = coxph_w_sum1(Ts,event,XB, Q,maxiter = 20)
coef_w_sum1_s[i,] = fit_w_sum1$coef
converge_w_sum1[i] = fit_w_sum1$converge
fit_w_sum2 = coxph_w_sum2(Ts,event,XB, Q, maxiter = 20)
coef_w_sum2_s[i,] = fit_w_sum2$coef
converge_w_sum2[i] = fit_w_sum2$converge
fit_estimate = Func_itteration(beta,beta0,lambda0,Ts,event,XB, Q,tol= 1e-6,maxits = 500)
coef_estimate_s[i,] = fit_estimate$beta0
converge_estimate[i] = as.numeric(fit_estimate$converge)
}
return(list( coef_true_s1 = coef_true_s[,1], coef_true_s2 = coef_true_s[,2],
coef_naive_s1 = coef_naive_s[,1], coef_naive_s2 = coef_naive_s[,2], coef_w_sum1_s1 = coef_w_sum1_s[,1],
coef_w_sum1_s2 = coef_w_sum1_s[,2], coef_w_sum2_s1 = coef_w_sum2_s[,1], coef_w_sum2_s2 = coef_w_sum2_s[,2],
coef_estimate_s1 = coef_estimate_s[,1], coef_estimate_s2 = coef_estimate_s[,2], converge_naive = converge_naive,
converge_w_sum1= converge_w_sum1,converge_w_sum2 = converge_w_sum2, converge_estimate = converge_estimate))  }
######################################
r_m = estimates_survival (nsim,n,m,C,p,beta,Q,lambda0,beta0)
R_T =cbind( mean ( r_m$coef_true_s1), mean(r_m$coef_true_s2))
R_N = cbind( mean ( r_m$coef_naive_s1), mean(r_m$coef_naive_s2 ))
R_2 = cbind( mean ( r_m$coef_w_sum1_s1 ), mean(r_m$coef_w_sum1_s2 ))
R_3 = cbind( mean ( r_m$coef_w_sum2_s1 ), mean(r_m$coef_w_sum2_s2 ))
R_4 = cbind( mean ( r_m$coef_estimate_s1 ), mean(r_m$coef_estimate_s2 ))
rbind(R_T, R_N ,R_2, R_3, R_4)
C_sample = cbind(c(0.6,0.2,0.2),c(0.7,0.15,0.15),c(0.8,0.1,0.1))
m = c(60,100,200)
n = round((80*m)/100)
p = 2
nsim = 3
beta = c(0.5,-0.5)
#lambda0 = rep(0.5,n)
#beta0 = c(0.1,0.1)
##############
scenarios = NULL
for (i in 1:ncol(C_sample)){
scenarios = rbind(scenarios,c(nsim,n[2],m[2],C_sample[,i]))
}
for (i in 4:6){
scenarios = rbind(scenarios,c(nsim,n[i-3],m[i-3],C_sample[,3]))
}
colnames(scenarios) = c("nsim","n","m","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
C_sample = cbind(c(0.6,0.2,0.2),c(0.7,0.15,0.15),c(0.8,0.1,0.1))
m = c(60,100,200)
n = round((80*m)/100)
p = 2
nsim = 3
beta = c(0.5,-0.5)
#lambda0 = rep(0.5,n)
#beta0 = c(0.1,0.1)
##############
scenarios = NULL
for (i in 1:ncol(C_sample)){
scenarios = rbind(scenarios,c(nsim,n[2],m[2],C_sample[,i]))
}
for (i in 4:6){
scenarios = rbind(scenarios,c(nsim,n[i-3],m[i-3],C_sample[,3]))
}
colnames(scenarios) = c("nsim","n","m","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
scenarios
setwd("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu")
for (i in (1:nrow(scenarios))){
nsim=scenarios[i,1]
n=scenarios[i,2]
m=scenarios[i,3]
C=vector()
C[1]=scenarios[i,4]
C[2]=scenarios[i,5]
C[3]=scenarios[i,6]
lambda0 = rep(0.5,n)
beta0 = c(0.1,0.1)
results_sample = estimates_survival(nsim,n,m,C,p,beta,Q,lambda0,beta0) #monte carlos
#filename = paste0("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu/Results/","nsim=",nsim," n = ",n," m = #",m,"  Prob_1 = ",C[1]," Prob_2 = ",C[2]," Prob_3 = ", C[3],".Rdata")
filename = paste0("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu/Results/","scenario=",i,
"_m=",m, "_prob1=", C[1], ".Rdata")
save(results_sample,file = filename)
}
# list of files to load
library(parallel)
file_list <- c("scenario=1_m=100_prob1=0.6.Rdata",
"scenario=2_m=100_prob1=0.7.Rdata",
"scenario=3_m=100_prob1=0.8.Rdata",
"scenario=4_m=60_prob1=0.8.Rdata",
"scenario=5_m=100_prob1=0.8.Rdata",
"scenario=6_m=200_prob1=0.8.Rdata")
path <- "C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu/Results/"
file_list <- paste0(path, file_list)
r = nrow(scenarios)
funct_tableau <- function(file_list,r,p){
beta_true = matrix(0,r,p )
beta_naive = matrix(0,r,p )
beta_w_sum1 = matrix(0,r,p )
beta_w_sum2 = matrix(0,r,p )
beta_estimate = matrix(0,r,p )
L_naive = vector()  # number of convergences
L_w_sum1 = vector()
L_w_sum2 = vector()
L_estimate = vector()
Sd_true = matrix(0,r,p ) # standard deviation
Sd_naive = matrix(0,r,p )
Sd_sum1 = matrix(0,r,p )
Sd_sum2 = matrix(0,r,p )
Sd_estimate = matrix(0,r,p )
rmse_true = matrix(0,r,p ) # mean squart error
rmse_naive = matrix(0,r,p )
rmse_sum1 = matrix(0,r,p )
rmse_sum2 = matrix(0,r,p )
rmse_estimate = matrix(0,r,p )
for (i in 1:length(file_list)) {
load(file_list[i])
results_sample = results_sample
beta_true[i,] = c (mean(results_sample$coef_true_s1), mean(results_sample$coef_true_s2))
beta_naive[i,] = rbind(  mean(results_sample$coef_naive_s1), mean(results_sample$coef_naive_s2))
beta_w_sum1[i,] = rbind( mean(results_sample$coef_w_sum1_s1), mean(results_sample$coef_w_sum1_s2))
beta_w_sum2[i,] = rbind( mean(results_sample$coef_w_sum2_s1), mean(results_sample$coef_w_sum2_s2))
beta_estimate[i,] = rbind( mean(results_sample$coef_estimate_s1 ), mean(results_sample$coef_estimate_s2 ))
L_naive[i] = length(which(results_sample$converge_naive==0))
L_w_sum1[i] = length(which(results_sample$converge_w_sum1==0))
L_w_sum2[i] = length( which(results_sample$converge_w_sum2==0))
L_estimate[i] = length(which(results_sample$converge_estimate==0))
Sd_true[i,] = rbind( sd(results_sample$coef_true_s1), sd(results_sample$coef_true_s2))
Sd_naive[i,] = rbind( sd( results_sample$coef_naive_s1) , sd( results_sample$coef_naive_s2) )
Sd_sum1[i,] = rbind( sd(results_sample$coef_w_sum1_s1), sd(results_sample$coef_w_sum1_s2))
Sd_sum2 [i,] = rbind( sd(results_sample$coef_w_sum2_s1),sd(results_sample$coef_w_sum2_s2))
Sd_estimate[i,] = rbind( sd(results_sample$coef_estimate_s1),sd(results_sample$coef_estimate_s2))
rmse_true[i,] = rbind (sqrt( mean((results_sample$coef_true_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_true_s2+  beta[2])^2)))
rmse_naive[i,] = rbind( sqrt( mean((results_sample$coef_naive_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_naive_s2+  beta[2])^2)))
rmse_sum1[i,] = rbind( sqrt( mean((results_sample$coef_w_sum1_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_w_sum1_s2- beta[2])^2)))
rmse_sum2[i,] = rbind( sqrt( mean((results_sample$coef_w_sum2_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_w_sum2_s2- beta[2])^2)))
rmse_estimate[i,] = rbind( sqrt( mean((results_sample$coef_estimate_s1 -  beta[1])^2)),
sqrt( mean((results_sample$coef_estimate_s2 -  beta[2])^2)))
}
return( list( beta_true = beta_true, beta_naive = beta_naive,beta_w_sum1=beta_w_sum1,                                     beta_w_sum2=beta_w_sum2, beta_estimate=beta_estimate,
L_naive =L_naive,L_w_sum1=L_w_sum1,L_w_sum2=L_w_sum2,L_estimate=L_estimate,
Sd_true= Sd_true,Sd_naive=Sd_naive ,Sd_sum1=Sd_sum1,  Sd_sum2=Sd_sum2, Sd_estimate =Sd_estimate,
rmse_true = rmse_true, rmse_naive = rmse_naive,rmse_sum1 = rmse_sum1, rmse_sum2 = rmse_sum2, rmse_estimate = rmse_estimate))
}
# one file
setwd("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu/Results/")
load("scenario=1_m=100_prob1=0.6.Rdata")
results_sample = results_sample
# list of files to load
library(parallel)
file_list <- c("scenario=1_m=100_prob1=0.6.Rdata",
"scenario=2_m=100_prob1=0.7.Rdata",
"scenario=3_m=100_prob1=0.8.Rdata",
"scenario=4_m=60_prob1=0.8.Rdata",
"scenario=5_m=100_prob1=0.8.Rdata",
"scenario=6_m=200_prob1=0.8.Rdata")
path <- "C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu/Results/"
file_list <- paste0(path, file_list)
r = nrow(scenarios)
funct_tableau <- function(file_list,r,p){
beta_true = matrix(0,r,p )
beta_naive = matrix(0,r,p )
beta_w_sum1 = matrix(0,r,p )
beta_w_sum2 = matrix(0,r,p )
beta_estimate = matrix(0,r,p )
L_naive = vector()  # number of convergences
L_w_sum1 = vector()
L_w_sum2 = vector()
L_estimate = vector()
Sd_true = matrix(0,r,p ) # standard deviation
Sd_naive = matrix(0,r,p )
Sd_sum1 = matrix(0,r,p )
Sd_sum2 = matrix(0,r,p )
Sd_estimate = matrix(0,r,p )
rmse_true = matrix(0,r,p ) # mean squart error
rmse_naive = matrix(0,r,p )
rmse_sum1 = matrix(0,r,p )
rmse_sum2 = matrix(0,r,p )
rmse_estimate = matrix(0,r,p )
for (i in 1:length(file_list)) {
load(file_list[i])
results_sample = results_sample
beta_true[i,] = c (mean(results_sample$coef_true_s1), mean(results_sample$coef_true_s2))
beta_naive[i,] = rbind(  mean(results_sample$coef_naive_s1), mean(results_sample$coef_naive_s2))
beta_w_sum1[i,] = rbind( mean(results_sample$coef_w_sum1_s1), mean(results_sample$coef_w_sum1_s2))
beta_w_sum2[i,] = rbind( mean(results_sample$coef_w_sum2_s1), mean(results_sample$coef_w_sum2_s2))
beta_estimate[i,] = rbind( mean(results_sample$coef_estimate_s1 ), mean(results_sample$coef_estimate_s2 ))
L_naive[i] = length(which(results_sample$converge_naive==0))
L_w_sum1[i] = length(which(results_sample$converge_w_sum1==0))
L_w_sum2[i] = length( which(results_sample$converge_w_sum2==0))
L_estimate[i] = length(which(results_sample$converge_estimate==0))
Sd_true[i,] = rbind( sd(results_sample$coef_true_s1), sd(results_sample$coef_true_s2))
Sd_naive[i,] = rbind( sd( results_sample$coef_naive_s1) , sd( results_sample$coef_naive_s2) )
Sd_sum1[i,] = rbind( sd(results_sample$coef_w_sum1_s1), sd(results_sample$coef_w_sum1_s2))
Sd_sum2 [i,] = rbind( sd(results_sample$coef_w_sum2_s1),sd(results_sample$coef_w_sum2_s2))
Sd_estimate[i,] = rbind( sd(results_sample$coef_estimate_s1),sd(results_sample$coef_estimate_s2))
rmse_true[i,] = rbind (sqrt( mean((results_sample$coef_true_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_true_s2+  beta[2])^2)))
rmse_naive[i,] = rbind( sqrt( mean((results_sample$coef_naive_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_naive_s2+  beta[2])^2)))
rmse_sum1[i,] = rbind( sqrt( mean((results_sample$coef_w_sum1_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_w_sum1_s2- beta[2])^2)))
rmse_sum2[i,] = rbind( sqrt( mean((results_sample$coef_w_sum2_s1- beta[1])^2)),
sqrt( mean((results_sample$coef_w_sum2_s2- beta[2])^2)))
rmse_estimate[i,] = rbind( sqrt( mean((results_sample$coef_estimate_s1 -  beta[1])^2)),
sqrt( mean((results_sample$coef_estimate_s2 -  beta[2])^2)))
}
return( list( beta_true = beta_true, beta_naive = beta_naive,beta_w_sum1=beta_w_sum1,                                     beta_w_sum2=beta_w_sum2, beta_estimate=beta_estimate,
L_naive =L_naive,L_w_sum1=L_w_sum1,L_w_sum2=L_w_sum2,L_estimate=L_estimate,
Sd_true= Sd_true,Sd_naive=Sd_naive ,Sd_sum1=Sd_sum1,  Sd_sum2=Sd_sum2, Sd_estimate =Sd_estimate,
rmse_true = rmse_true, rmse_naive = rmse_naive,rmse_sum1 = rmse_sum1, rmse_sum2 = rmse_sum2, rmse_estimate = rmse_estimate))
}
r = nrow(scenarios)
p = 2
Results_scenario = funct_tableau(file_list,r,p)
r = nrow(scenarios)
p = 2
Results_scenario = as.data.frame(funct_tableau(file_list,r,p))
### boxplots
setwd("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu")
source("scenarios.R")
source("8_scenarios.R")
scenarios[1,]
scenarios[4,]
scenarios[6,]
library(ggplot2)
library(gridExtra)
levelsvec = numeric(0)
