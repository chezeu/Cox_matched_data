gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
#### values for q*exp(beta x) pour tilfe_f
som1 = prob%*%eXbeta
###  values for q*x*exp(beta x)
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
## Estimating equations
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 = colsums(Z*event)-(som2%*% (Ts/gamma0)^alpha0 )
s = c(L_1,L_2,L_3 )
return(s=s)
}
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(beta_ini[1],beta_ini[2]), maxiter = maxiter)
prob=Functio_prob(beta0,lambda0,lambda2,Ts,event,XB,Q)
sf=Funct_lambda(gamma0,alpha0,Ts)
Funct_lambda<-function(gamma0,alpha0,Ts){
#lambda0<- rep(0.1,length(event))
n = length(Ts)
lambda0 = vector()
lambda2 = vector()
for (i in 1:n) {
lambda0[i] = (alpha0*(Ts[i])^(alpha0 -1))/( gamma0^alpha0)
lambda2[i] = (Ts[i]/gamma0)^alpha0
}
return(list(lambda0= lambda0,lambda2=lambda2))
}
sf=Funct_lambda(gamma0,alpha0,Ts)
lambda0=sf$lambda0
lambda2=sf$lambda2
Functio_prob<-function(beta0,lambda0,lambda2,Ts,event,XB,Q){
#beta0<- c(0.1,0.1)
#alpha0<- 0.1
#gamma0<- 0.1
X = as.matrix(XB, ncol = p) # covariates
eXbeta0 = exp(X%*% beta0)
n = length(Ts)
m = nrow(XB)
#pi(ij)
prob = matrix(0,n,m)
for (i in 1:n) {
numerateur = vector()
for (j in 1:m) {
numerateur[j] = Q[i,j] * ( lambda0[i]*eXbeta0[j])^event[i] * exp(-lambda2[i]* eXbeta0[j] )
}
denominateur = sum(numerateur)
prob[i,] = numerateur/denominateur
}
prob
return( prob = prob)
}
prob= Functio_prob(beta0,lambda0,lambda2,Ts,event,XB,Q)
s = c(beta,gamma0,alpha0)
solv_equations <- function(s, prob,Ts,event,XB) {
p = ncol(XB)
n = length(Ts)
beta = s[1:2]
gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
#### values for q*exp(beta x) pour tilfe_f
som1 = prob%*%eXbeta
###  values for q*x*exp(beta x)
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
## Estimating equations
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 = colsums(Z*event)-(som2%*% (Ts/gamma0)^alpha0 )
s = c(L_1,L_2,L_3 )
return(s=s)
}
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(beta_ini[1],beta_ini[2]), maxiter = maxiter)
solv_equations <- function(s, prob,Ts,event,XB) {
p = ncol(XB)
n = length(Ts)
beta = s[1:2]
gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
#### values for q*exp(beta x) pour tilfe_f
som1 = prob%*%eXbeta
###  values for q*x*exp(beta x)
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
## Estimating equations
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 =colSums (Z*event)-(som2%*% (Ts/gamma0)^alpha0 )
s = c(L_1,L_2,L_3 )
return(s=s)
}
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(beta_ini[1],beta_ini[2]), maxiter = maxiter)
(Ts/gamma0)^alpha0
som2
p = ncol(XB)
n = length(Ts)
beta = s[1:2]
gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
som1 = prob%*%eXbeta
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 =colSums (Z*event)-(som2%*% (Ts/gamma0)^alpha0 )
som2
(Z*event)
som2* (Ts/gamma0)^alpha0
colSums (Z*event)
colSums (som2* (Ts/gamma0)^alpha0 )
solv_equations <- function(s, prob,Ts,event,XB) {
p = ncol(XB)
n = length(Ts)
beta = s[1:2]
gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
#### values for q*exp(beta x) pour tilfe_f
som1 = prob%*%eXbeta
###  values for q*x*exp(beta x)
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
## Estimating equations
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 =colSums (Z*event)-colSums (som2* (Ts/gamma0)^alpha0 )
s = c(L_1,L_2,L_3 )
return(s=s)
}
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(beta_ini[1],beta_ini[2]), maxiter = maxiter)
s
beta_ini
maxiter
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
fit_manual$root
########################################################
# data generation of the bigger data base
Generate_data <- function(m,n,beta){
# set.seed(42)
##covarites data
X1 = rnorm(m,0,1)
X2 = rbinom(m,size = 1, prob = 0.8)
X  = as.matrix(cbind(X1, X2))
U  = runif(m,0,1) # Time to event variable
Tt = -log(U)/exp((X%*%beta))#lambda=1
# Constant right censored
#c = quantile(Tt[,1], probs = 0.75)
c  = 1.777907
Time      = pmin(Tt,c) # le vrai temps
delta     = as.numeric(Tt<=c)
surv_data = data.frame(Time,delta,X)
colnames(surv_data) = c('Time','delta',paste("X", 1:2, sep = ""))
return(surv_data=surv_data )
}
######### Q matrix construction
Matrix_function<-function(n,m,C,beta, surv_data){
X  =  surv_data[,3:(p+2)]
XB = as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true = surv_data[1:n,]
data_A = surv_data[1:n,1:2] #Survival time and censored indicator
Q = matrix(0,n,m)
Lvec = matrix(0,n,m) #multinomial generation of the naive covariable
for (i in 1:n) {
if(i!=1 & i!=n){
pro = rep(0,m)
pro[i] = C[1] #Probability of True links (the highest proba)
pro[i+1]= C[3]
pro[i-1]=C[3]
Q[i,]<-pro
Lvec[i,] <- rmultinom(1, size = 1, pro = pro)}
if(i==1)  {
pro = rep(0,m)
pro[i] =  C[1] #Probability of True links
pro[i+1]= C[2]
pro[i+2]= C[3]
Q[i,]<-pro
Lvec[i,] <- rmultinom(1, size = 1, pro = pro)}
if(i==n){
pro = rep(0,m)
pro[i] = C[1] #Probability of True links
pro[i-1]=C[2]
pro[i-2]=C[3]
Q[i,]<-pro
Lvec[i,] <- rmultinom(1, size = 1, pro= pro) }
}
Lvec
X_naive <-Lvec %*% XB # the naive covariables
colnames(X_naive)<- c("Z1","Z2")
# Naive data
data_naive <- cbind( data_A, X_naive)
return(list( data_true=data_true, data_A= data_A,XB=XB, data_naive=data_naive,Q=Q, Lvec= Lvec))
}
############### SCENARIOS
C_sample = rbind(c(0.6,0.2,0.2),c(0.7,0.2,0.1),c(0.8,0.1,0.1))
m_sample = c(100,300,800)
n_sample = round((80*m_sample)/100)
p = 2
nsim = 30
beta = c(0.5,-0.5)
#lambda0 = rep(0.5,n)
#beta0 = c(0.1,0.1)
#beta = c(0.5,-0.5)
############## Table of scenarios
scenarios = NULL
for (i in 1:length(m_sample)){
m= m_sample[i]
n= n_sample[i]
for (j in 1: nrow(C_sample)) {
scenarios = rbind(scenarios,c(nsim,m,n,C_sample[j,]))
}
}
colnames(scenarios) = c("nsim","m","n","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
#####################
C=c(0.8,0.1, 0.1)
beta0 = c(0.1,0.1)
beta = c(0.5,-0.5)
library(survival)
library(rootSolve)
library(nleqslv)
Funct_lambda<-function(gamma0,alpha0,Ts){
#lambda0<- rep(0.1,length(event))
n = length(Ts)
lambda0 = vector()
lambda2 = vector()
for (i in 1:n) {
lambda0[i] = (alpha0*(Ts[i])^(alpha0 -1))/( gamma0^alpha0)
lambda2[i] = (Ts[i]/gamma0)^alpha0
}
return(list(lambda0= lambda0,lambda2=lambda2))
}
surv_data = Generate_data(m,n,beta)
mf = Matrix_function(n,m,C,beta,surv_data)
data_true = mf$data_true
data_naive = mf$data_naive
Ts = mf$data_true$Time
event = mf$data_true$delta
Q = mf$Q
XB = mf$XB
Funct_lambda<-function(gamma0,alpha0,Ts){
#lambda0<- rep(0.1,length(event))
n = length(Ts)
lambda0 = vector()
lambda2 = vector()
for (i in 1:n) {
lambda0[i] = (alpha0*(Ts[i])^(alpha0 -1))/( gamma0^alpha0)
lambda2[i] = (Ts[i]/gamma0)^alpha0
}
return(list(lambda0= lambda0,lambda2=lambda2))
}
sf=Funct_lambda(gamma0,alpha0,Ts)
alpha0=0.1
gamma0=0.1
Funct_lambda<-function(gamma0,alpha0,Ts){
#lambda0<- rep(0.1,length(event))
n = length(Ts)
lambda0 = vector()
lambda2 = vector()
for (i in 1:n) {
lambda0[i] = (alpha0*(Ts[i])^(alpha0 -1))/( gamma0^alpha0)
lambda2[i] = (Ts[i]/gamma0)^alpha0
}
return(list(lambda0= lambda0,lambda2=lambda2))
}
sf=Funct_lambda(gamma0,alpha0,Ts)
lambda0=sf$lambda0
lambda2=sf$lambda2
lambda0
Functio_prob<-function(beta0,lambda0,lambda2,Ts,event,XB,Q){
#beta0<- c(0.1,0.1)
#alpha0<- 0.1
#gamma0<- 0.1
X = as.matrix(XB, ncol = p) # covariates
eXbeta0 = exp(X%*% beta0)
n = length(Ts)
m = nrow(XB)
#pi(ij)
prob = matrix(0,n,m)
for (i in 1:n) {
numerateur = vector()
for (j in 1:m) {
numerateur[j] = Q[i,j] * ( lambda0[i]*eXbeta0[j])^event[i] * exp(-lambda2[i]* eXbeta0[j] )
}
denominateur = sum(numerateur)
prob[i,] = numerateur/denominateur
}
prob
return( prob = prob)
}
prob= Functio_prob(beta0,lambda0,lambda2,Ts,event,XB,Q)
s = c(beta,gamma0,alpha0)
solv_equations <- function(s, prob,Ts,event,XB) {
p = ncol(XB)
n = length(Ts)
beta = s[1:2]
gamma0 = s[3]
alpha0= s[4]
X = as.matrix(XB, ncol = p) # covariates
eXbeta = exp(X%*% beta)
XeXbeta = X*matrix(rep(exp(X%*% beta),p), ncol = p)
D = sum(event)
Z = prob%*%X
#### values for q*exp(beta x) pour tilfe_f
som1 = prob%*%eXbeta
###  values for q*x*exp(beta x)
som2 = prob%*%XeXbeta
dat1 = cbind(Ts, Z)[which(event==1),]
## Estimating equations
L_1 = (D/alpha0)+ sum(event*log(Ts/gamma0))- sum(som1*log(Ts/gamma0)*((Ts/gamma0))^alpha0)
L_2 = -( (D* alpha0)/gamma0) + ((alpha0/ gamma0)* sum( som1* (Ts/gamma0)^alpha0))
L_3 =colSums (Z*event)-colSums (som2* (Ts/gamma0)^alpha0 )
s = c(L_1,L_2,L_3 )
return(s=s)
}
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
maxiter = 20
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
coxph_estimate<- function(prob,Ts,event,XB,beta_ini,maxiter = 20){
s=c(beta,gamma0,alpha0)
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
# fit_manual <- nleqslv( c(beta_ini[1],beta_ini[2]),f, method = c("Broyden", "Newton"))
# beta0 <- fit_manual$x
#iterations <- fit_manual$iter
# converge <- as.numeric(( iterations< maxiter)& (fit_manual$scalex==1) )
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
beta0 = fit_manual$root
iterations =  fit_manual$iter
converge = as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list( beta0 = beta0, converge = converge, iterations = iterations) )
}
coxph_estimate2<- function(prob,Ts,event,XB,beta_ini,maxiter = 20){
s=c(beta,gamma0,alpha0)
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
# fit_manual <- nleqslv( c(beta_ini[1],beta_ini[2]),f, method = c("Broyden", "Newton"))
# beta0 <- fit_manual$x
#iterations <- fit_manual$iter
# converge <- as.numeric(( iterations< maxiter)& (fit_manual$scalex==1) )
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
beta0 = fit_manual$root
iterations =  fit_manual$iter
converge = as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list( beta0 = beta0, converge = converge, iterations = iterations) )
}
fit_estimate = coxph_estimate2(prob,Ts,event,XB,beta_ini,maxiter = 20)
beta_ini
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
vi= solv_equations (s, prob,Ts,event,XB)
vi
coxph_estimate2<- function(prob,Ts,event,XB,maxiter = 20){
s=c(beta,gamma0,alpha0)
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
# fit_manual <- nleqslv( c(beta_ini[1],beta_ini[2]),f, method = c("Broyden", "Newton"))
# beta0 <- fit_manual$x
#iterations <- fit_manual$iter
# converge <- as.numeric(( iterations< maxiter)& (fit_manual$scalex==1) )
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
fit_manual = multiroot(f,start = c(0,0,0,0), maxiter = maxiter)
beta0 = fit_manual$root
iterations =  fit_manual$iter
converge = as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list( beta0 = beta0, converge = converge, iterations = iterations) )
}
fit_estimate = coxph_estimate2(prob,Ts,event,XB,maxiter = 20)
fit_manual <- nleqslv( c(0,0,0,0),f, method = c("Broyden", "Newton"))
fit_manual$x
f <- function(x){
solv_equations (s, prob,Ts,event,XB)
}
fit_manual <- nleqslv( c(0,0,0,0),f, method = c("Broyden", "Newton"))
fit_manual
############### SCENARIOS
C_sample = rbind(c(0.6,0.2,0.2),c(0.7,0.2,0.1),c(0.8,0.1,0.1))
m_sample = c(100,500,700)
n_sample = round((80*m_sample)/100)
p = 2
nsim = 10
beta = c(0.5,-0.5)
#lambda0 = rep(0.5,n)
#beta0 = c(0.1,0.1)
#beta = c(0.5,-0.5)
############## Table of scenarios
scenarios = NULL
for (i in 1:length(m_sample)){
m= m_sample[i]
n= n_sample[i]
for (j in 1: nrow(C_sample)) {
scenarios = rbind(scenarios,c(nsim,m,n,C_sample[j,]))
}
}
colnames(scenarios) = c("nsim","m","n","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
#####################
C=c(1,0,0)
#data generation
surv_data = Generate_data(m,n,beta)
library(survival)
library(rootSolve)
library(nleqslv)
setwd("C:/Users/fchezeut/Documents/GitHub/Cox_matched_data/code_Q_connu")
source("1_data_generate.R")
source("2_risk_function.R")
source("3_naive_method.R")
source("4_method_w_sum1.R")
source("5_method_w_sum2.R")
source("6_method_EM.R")
source("EM_with_N_d.R")
source("7_scenarios.R")
#data generation
surv_data = Generate_data(m,n,beta)
mf = Matrix_function(n,m,C,beta,surv_data)
data_true = mf$data_true
data_naive = mf$data_naive
Ts = mf$data_true$Time
event = mf$data_true$delta
Q = mf$Q
XB = mf$XB
Z = as.matrix(data_naive[,3:(p+2)])
lambda0 =  rep(0.1,length(event))
L = which(event == 0)
lambda0 [L] = 0
beta0 = c(0.1,0.1)
# Theoretical estimating equation for true and naive data
fit_true = coxph(Surv(Time,delta)~.,data = data_true)
as.vector(fit_true$coefficients)
# naive method
fit_naive = coxph_equa_naive(Ts,event, Z, maxiter = 20)
fit_naive$coef
# method with weighted average
fit_w_sum1 = coxph_w_sum1(Ts,event,XB, Q,maxiter = 20)
fit_w_sum1$coef
#method with the maximum of proba
fit_w_sum2 = coxph_w_sum2(Ts,event,XB, Q, maxiter = 20)
fit_w_sum2$coef
# EM method
fit_estimate = Func_itteration(beta0,lambda0,Ts,event,XB, Q,tol= 1e-6,maxits = 500)
fit_estimate$beta0
# EM with N_d
fit_estimate_Nd = Func_itteration_Nd(beta0,lambda0,Ts,event,XB, Q,tol= 1e-6,maxits = 500)
fit_estimate_Nd$beta0
