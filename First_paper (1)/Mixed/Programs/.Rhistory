Z <- as.matrix(data_naive[,(pA+3):(p+2)])
XB <- XB
betaA <- beta[1:pA]
betaB <- beta[(pA+1):p]
Y <- cbind(XA,Z)
muZ <- exp(Z%*% betaB)
psiZ <- Z*matrix(rep(exp(Z%*% betaB),pB), ncol = pB)
muXA <- exp(XA%*% betaA)
psiXA <- XA*matrix(rep(exp(XA%*% betaA),pA), ncol = pA)
if (Q == 1){
XB <- as.matrix(XB[,1:pB])
mean.muXB <- mean(exp(XB%*%betaB))
mean.psiXB <- colMeans((XB*matrix(rep(exp(XB %*% betaB),pB),ncol = pB)))
temp1 <- Z/alpha - (1/alpha-1)*matrix(rep(colMeans(XB),n), nrow = n, byrow = TRUE)
temp1 <- cbind(XA, temp1)
dat <- cbind(Ts, temp1)[which(event==1),]
## Estimating equation
ee <- apply(dat, 1,
function(df){
df <- matrix(df, nrow = 1)
ts <- df[, 1]
t1R <- df[, 2:ncol(df)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
t2R <- sum(muXA[risk]*muZ[risk])/alpha-(1/alpha-1)*mean.muXB*sum(muXA[risk])
t3A <- colSums(matrix(psiXA[risk,]*muZ[risk], ncol = pA))/alpha - (1/alpha-1)*mean.muXB*colSums(matrix(psiXA[risk,], ncol = pA))
t3B <- colSums(matrix(psiZ[risk,]*muXA[risk], ncol = pB))/alpha - (1/alpha-1)*mean.psiXB*sum(muXA[risk])
t3R <- c(t3A, t3B)
return((t1R - t3R / t2R))
}) %>%
matrix(nrow = p)%>%
rowSums()
}
else if(Q>1){
alpha.Q <- matrix(0, ncol = 1, nrow = n)
meanXB.Q <- matrix(0, ncol = pB, nrow = n)
mean.muXB.Q <- matrix(0, ncol = 1, nrow = n)
mean.psiXB.Q <- matrix(0, ncol = pB, nrow = n)
for (q in 1:Q) {
alpha.Q[which(data_naive$block == q),] <- alpha[q]
XB.q <- as.matrix(XB[which(XB$block == q),1:pB])
n.q <- length(which(data_naive$block == q))
meanXB.Q[which(data_naive$block == q),] <- matrix(rep(colMeans(XB.q),n.q), nrow = n.q, byrow = TRUE)
mean.muXB.Q[which(data_naive$block == q),] <- mean(exp(XB.q%*%betaB))
mean.psiXB.Q[which(data_naive$block == q),] <- matrix(rep(colMeans((XB.q*matrix(rep(exp(XB.q %*% betaB),pB),ncol =pB))),n.q), nrow = n.q, byrow = TRUE)
}
temp1 <- Z/matrix(rep(alpha.Q,pB),ncol = pB) - matrix(rep(1/alpha.Q-1,pB),ncol = pB)*meanXB.Q
temp1 <- cbind(XA, temp1)
temp2 <- (muXA*muZ)/alpha.Q - (1/alpha.Q-1)*mean.muXB.Q*muXA
temp3A <- psiXA*matrix(rep(muZ, pA), ncol = pA)/matrix(rep(alpha.Q,pA),ncol = pA)- matrix(rep(1/alpha.Q-1,pA),ncol = pA)*matrix(rep(mean.muXB.Q, pA), ncol = pA)*psiXA
temp3B <- psiZ*matrix(rep(muXA, pB), ncol = pB)/matrix(rep(alpha.Q,pB),ncol = pB) - matrix(rep(1/alpha.Q-1,pB),ncol = pB)*mean.psiXB.Q*matrix(rep(muXA, pB), ncol = pB)
dat <- cbind(Ts, temp1)[which(event==1),]
## Estimating equation
ee <- apply(dat, 1,
function(df){
df <- matrix(df, nrow = 1)
ts <- df[, 1]
t1R <- df[, 2:ncol(df)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
t2R <- sum(temp2[risk])
t3A <- colSums(as.matrix(temp3A[risk,]))
t3B <- colSums(as.matrix(temp3B[risk,]))
t3R <- c(t3A, t3B)
return((t1R - t3R / t2R))
}) %>%
matrix(nrow = p)%>%
rowSums()
}
return(ee)
}
#3. Estimating equation solving
coxph_aee <- function(data_naive, XB, pA, pB, alpha, Q, maxiter = 20){
f <- function(x){
aee(beta = x, data_naive=data_naive, XB = XB, pA = pA, pB = pB, alpha = alpha, Q = Q)
}
fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
beta <- fit_manual$root
converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge))
}
library(survival)
# n = 1000
# N = 2000
# pA = 3
# pB = 1
# p = pA+pB
# beta = matrix(rep(0.5,p), nrow = p)
# rho = 0.75
# alpha = 0.85
# block = 3
nvec = c(26,1348,5,57,1552)
Nvec = c(26,1348,5,57,1552)
pA = 3 #fixed
pB = 1 #fixed
p = pA+pB
alpha = c(5,6,7,8,9)/9
Q = 5
beta = matrix(c(0.064, -0.133, 0.746, -0.35), nrow = p)
rho = 0.55
data <- generate_full_mixed(Q, nvec, Nvec, alpha, pA, pB, beta, rho)
data_true <- data$data_true
data_naive <- data$data_naive
XB = data$XB
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
fit_true
fit_naive <- coxph(Surv(Time,delta)~.,data = data_naive[,1:(p+2)])
fit_naive
fit_aee <- coxph_aee(data_naive, XB, pA, pB, alpha = alpha, Q=5, maxiter = 20 )
fit_aee$coef
library(mvtnorm)
library(glmnet)
library(matrixStats)
library(clue)
# This function generate survival data
# Sample size: N
# Number of Gaussian covariates: p
# True values of coeficients: beta
# Proportion of non-censoring: rho
generate_surv_cont= function(N, p, beta, rho ){
if (p==2){
corX <- diag(p)
mX <- c(0,2)
X <- mvtnorm::rmvnorm(N, mean=mX, sigma = corX)
}else{
corX <- diag(p)
mX <- rep(0,p)
X <- mvtnorm::rmvnorm(N, mean=mX, sigma = corX)
}
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored: Do you think this can cause problem?
C = quantile(Tt, probs = rho)
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Surival data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# Generate surival time with two binary covariates
generate_surv_binary <- function(N, p, beta, rho ){
if (p==1){
X <- matrix(rbinom(N, size = 1, prob = 0.7), ncol = p)
}else if (p==2){
X <- matrix(c(rbinom(N, size = 1, prob = 0.7), rbinom(N, size = 1, prob = 0.5)), ncol = p)
}
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored
C = quantile(Tt, probs = rho)
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# Genrate survival time with one normal covariate and one binary covariate
generate_surv_mixed = function(N, p, beta, rho ){
# Two first continuous variables, then all binary
X1 <- rnorm(N,75,13)
X2 <- rbinom(N,size = 1, prob = 0.53)
X3 <- rbinom(N,size = 1, prob = 0.145)
X4 <- rbinom(N,size = 1, prob = 0.11)
X <- as.matrix(cbind(X1, X2, X3, X4))
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored:
C = quantile(Tt, probs = rho)
#C = 1.777907
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Surival data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# This function generates two databases A and B with
# n: Number on individuals in A
# N: Number of individuals in B
# p: Number of covariates
# beta: True coefficients
# rho: Proportion of non-censoring
# alpha_q: Record linkage quality
generate_linked_cont <- function(n, N, p, beta, rho , alpha_q){
# Survival data (Database B)
surv_data <- generate_surv_cont(N,p, beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_linked_binary <- function(n, N, p, beta, rho , alpha_q){
# Survival data
surv_data <- generate_surv_binary(N,p,beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p)
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2]
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
##################################### 1 block ###########################
generate_1block_mixed <- function(n, N, pA, pB, beta, rho, alpha_q, block){
blockA = rep(block, n)
blockB = rep(block, N)
p = pA+ pB
# Survival data (Database B)
surv_data <- generate_surv_mixed(N, p, beta, rho)
X <- as.matrix(surv_data[,3:ncol(surv_data)])
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive, block= blockA)
data_naive[,3:(pA+2)] <- data_true[, 3:(pA+2)]
XB <- as.data.frame(cbind(X, block = blockB))
XB <- XB[,(pA+1): (p+1)]
trueLink_id <- cbind(diag(L), block = blockA)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_full_mixed <- function(Q, nvec, Nvec, alpha, pA, pB, beta, rho){
# Q >= 2
n = nvec[1]
N = Nvec[1]
alpha_q = alpha[1]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho , alpha_q, block = 1)
data_true <- data_block$data_true
data_naive <- data_block$data_naive
XB <- data_block$XB
trueLink_id <- data_block$trueLink_id
for (i in 2:Q){
n = nvec[i]
N = Nvec[i]
alpha_q = alpha[i]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho, alpha_q, block = i)
data_true <- rbind(data_true,data_block$data_true)
data_naive <- rbind(data_naive,data_block$data_naive)
XB <- rbind(XB,data_block$XB)
trueLink_id <- rbind(trueLink_id, data_block$trueLink_id)
}
return(list(data_true = data_true,  XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
library(survival)
# n = 1000
# N = 2000
# pA = 3
# pB = 1
# p = pA+pB
# beta = matrix(rep(0.5,p), nrow = p)
# rho = 0.75
# alpha = 0.85
# block = 3
nvec = c(26,1348,5,57,1552)
Nvec = c(26,1348,5,57,1552)
pA = 3 #fixed
pB = 1 #fixed
p = pA+pB
alpha = c(5,6,7,8,9)/9
Q = 5
beta = matrix(c(0.064, -0.133, 0.746, -0.35), nrow = p)
rho = 0.55
data <- generate_full_mixed(Q, nvec, Nvec, alpha, pA, pB, beta, rho)
data_true <- data$data_true
data_naive <- data$data_naive
XB = data$XB
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
fit_true
3535-1792
170*8/9+11*7/9+1500*6/9+58*5/6+4*4/9
(170*8/9+11*7/9+1500*6/9+58*5/6+4*4/9)/1743
library(fastLink)
dfA
library(fastLink)
dfA
library(simsalapar)
library(doParallel)
library(clue)
library(matrixStats)
library(ludic)
library(maxLik)
library(Rfast)
library(mvtnorm)
library(mixtools)
library(EnvStats)
library(fastLink)
library(mixR)
setwd("C:\\Users\\thhvo.BCOM\\Dropbox\\R_program\\First_paper\\Mixed\\Programs")
source("m1_generate_data.R")
source("m2_compare.R")
source("m3_EM.R")
source("m4_methods.R")
data = generate_data(nA = nA, nB = nB, K1 = K1, K2 = K2, K3 = K3,
error1 = error1, error2 = error2, error3 = error3,
prev2 = prev2, lambda3 = lambda3, mu3 = mu3)
datA = data$dataA
nA= 500
nB = 200
K1 = 2
K2 = 2
K3=2
error1 = 0.1
error2 = 0.2
error3 = 0.2
error2 = 0.04
prev2 = 0.01
lambda3 = 0.01
mu3 = 2
data = generate_data(nA = nA, nB = nB, K1 = K1, K2 = K2, K3 = K3,
error1 = error1, error2 = error2, error3 = error3,
prev2 = prev2, lambda3 = lambda3, mu3 = mu3)
datA = data$dataA
datB = data$dataB
datA
head(datA)
head(datB)
fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"))
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"))
fit$matches
fit$EM
fit$posterior
fit$EM$p.m
fit$EM$p.u
fit$EM$zeta.j
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5)
fit$matches
datA
datB
c(datB$id, fit$matches)
datB$id
cbind(datB$id, fit$matches)
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.001)
fit$posterior
datA
datB
cbind(datB$id, fit$matches)
fit$matches
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.0)
fit$matches
nA = nrow(datA)
nB =  nrow(datB)
K = K1 + K2 +K3
comp_mat = compare_binary(datA, datB, K)
fit = EM_binary(comp_mat, datA, datB, K)
g = fit$g
converge = fit$converge
threshold = 0.5
index = which(g>= threshold)
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5)
fit$matches
nrow(fit$matches)
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5, return.all = FALSE)
fit$matches
fit$posterior
fit$EM$zeta.j
fit$patterns
fit$EM$patterns.w
ret <- getMatches(dfA, dfB, fit)
ret
ret <- getMatches(datA, datB, fit)
ret
nrow(ret)
length(index)
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5, dedupe.matches = FALSE)
fit$matches
data = generate_data(nA = nA, nB = nB, K1 = K1, K2 = K2, K3 = K3,
error1 = error1, error2 = error2, error3 = error3,
prev2 = prev2, lambda3 = lambda3, mu3 = mu3)
datA = data$dataA
datB = data$dataB
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5, dedupe.matches = FALSE)
fit$matches
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5)
fit$matches
nA = nrow(datA)
nB =  nrow(datB)
K = K1 + K2 +K3
comp_mat = compare_binary(datA, datB, K)
fit = EM_binary(comp_mat, datA, datB, K)
g = fit$g
converge = fit$converge
threshold = 0.5
index = which(g>= threshold)
K <- K1+K2+K3
rpairs <- compare.linkage(datA[,1:K], datB[,1:K], identity1 = datA[, K+1], identity2 = datB[,K+1])
weights <- emWeights(rpairs)
p = 1/nrow(datA)
q = 0.5
# Relation between matching probability threshold and FS score
threshold <- log2((1-p)/(1-q)*q/p)
results <- emClassify(weights, threshold)
nrow(results)
results
results$prediction
length(which(results$prediction=="L"))
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), threshold.match = 0.5)
fit$matches
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), tol.em = 1e-6, threshold.match = 0.5)
fit$matches
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), tol.em = 1e-6, estimate.only = TRUE, threshold.match = 0.5)
fit$zeta.j
fit$patterns.w
fit$p.gamma.k.m
fit = fastLink(datA, datB, varnames = c("R1", "R2", "R3", "R4", "R5", "R6"), tol.em = 1e-6, threshold.match = 0.5)
fit$matches
datA
datB
fl.matches <- fit$matches
datB$id[fl.matches$inds.b]
sum(datB$id[fl.matches$inds.b] == fl.matches$inds.a)
TPR = sum(datB$id[fl.matches$inds.b] == fl.matches$inds.a)/nB
fl = fastLink(datA, datB, varnames = c(paste("R", 1:(K1+K2+K3), sep = "")), tol.em = 1e-6, threshold.match = 0.5)
TPR = sum(datB$id[fl.matches$inds.b] == fl.matches$inds.a)/nrow(datB)
PPV = sum(datB$id[fl.matches$inds.b] == fl.matches$inds.a)/nrow(fl.matches)
library(tictoc)
source("m1_generate_data.R")
source("m2_compare.R")
source("m3_EM.R")
source("m4_methods.R")
data = generate_data(nA = nA, nB = nB, K1 = K1, K2 = K2, K3 = K3,
error1 = error1, error2 = error2, error3 = error3,
prev2 = prev2, lambda3 = lambda3, mu3 = mu3)
datA = data$dataA
datB = data$dataB
tic()
FS_mixed <- FS_mixed(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_mixed <- temp$toc-temp$tic
tic()
FS_binary <- FS_binary(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_binary = temp$toc - temp$tic
tic()
FS_RecordLinkage <- FS_RecordLinkage(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_RecordLinkage = temp$toc - temp$tic
tic()
FS_fastLink<- FS_fastLink(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_fastLink = temp$toc - temp$tic
results <- c(FS_mixed, FS_binary, FS_RecordLinkage, FS_fastLink, time_FS_mixed, time_FS_binary, time_FS_RecordLinkage, time_FS_fastLink)
results
source("m1_generate_data.R")
source("m2_compare.R")
source("m3_EM.R")
source("m4_methods.R")
data = generate_data(nA = nA, nB = nB, K1 = K1, K2 = K2, K3 = K3,
error1 = error1, error2 = error2, error3 = error3,
prev2 = prev2, lambda3 = lambda3, mu3 = mu3)
datA = data$dataA
datB = data$dataB
tic()
FS_mixed <- FS_mixed(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_mixed <- temp$toc-temp$tic
tic()
FS_binary <- FS_binary(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_binary = temp$toc - temp$tic
tic()
FS_RecordLinkage <- FS_RecordLinkage(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_RecordLinkage = temp$toc - temp$tic
tic()
FS_fastLink<- FS_fastLink(datA, datB, K1, K2, K3)
temp = toc(quiet = TRUE)
time_FS_fastLink = temp$toc - temp$tic
results <- c(FS_mixed, FS_binary, FS_RecordLinkage, FS_fastLink, time_FS_mixed, time_FS_binary, time_FS_RecordLinkage, time_FS_fastLink)
results
