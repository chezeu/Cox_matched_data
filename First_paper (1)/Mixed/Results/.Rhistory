X2 <- rbinom(N,size = 1, prob = 0.53)
X3 <- rbinom(N,size = 1, prob = 0.145)
X4 <- rbinom(N,size = 1, prob = 0.11)
X <- as.matrix(cbind(X1, X2, X3, X4))
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored:
C = quantile(Tt, probs = rho)
#C = 1.777907
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Surival data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# This function generates two databases A and B with
# n: Number on individuals in A
# N: Number of individuals in B
# p: Number of covariates
# beta: True coefficients
# rho: Proportion of non-censoring
# alpha_q: Record linkage quality
generate_linked_cont <- function(n, N, p, beta, rho , alpha_q){
# Survival data (Database B)
surv_data <- generate_surv_cont(N,p, beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_linked_binary <- function(n, N, p, beta, rho , alpha_q){
# Survival data
surv_data <- generate_surv_binary(N,p,beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p)
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2]
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
##################################### 1 block ###########################
generate_1block_mixed <- function(n, N, pA, pB, beta, rho, alpha_q, block){
blockA = rep(block, n)
blockB = rep(block, N)
p = pA+ pB
# Survival data (Database B)
surv_data <- generate_surv_mixed(N, p, beta, rho)
X <- as.matrix(surv_data[,3:ncol(surv_data)])
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive, block= blockA)
data_naive[,3:(pA+2)] <- data_true[, 3:(pA+2)]
XB <- as.data.frame(cbind(X, block = blockB))
XB <- XB[,(pA+1): (p+1)]
trueLink_id <- cbind(diag(L), block = blockA)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_full_mixed <- function(Q, nvec, Nvec, alpha, pA, pB, beta, rho){
# Q >= 2
n = nvec[1]
N = Nvec[1]
alpha_q = alpha[1]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho , alpha_q, block = 1)
data_true <- data_block$data_true
data_naive <- data_block$data_naive
XB <- data_block$XB
trueLink_id <- data_block$trueLink_id
for (i in 2:Q){
n = nvec[i]
N = Nvec[i]
alpha_q = alpha[i]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho, alpha_q, block = i)
data_true <- rbind(data_true,data_block$data_true)
data_naive <- rbind(data_naive,data_block$data_naive)
XB <- rbind(XB,data_block$XB)
trueLink_id <- rbind(trueLink_id, data_block$trueLink_id)
}
return(list(data_true = data_true,  XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
library(survival)
library(plyr)
library(dplyr)
library(rootSolve)
#1. Finding the risk set R(t) given some time t
GetRiskSet <- function(time_of_interest, time_vector, event_vector) {
return(which(((time_vector == time_of_interest & event_vector == 1) | (time_vector > time_of_interest))))
}
#2. Proposed estimating equations
aee <- function(beta, data_naive, XB, pA, pB, alpha, Q) {
#pA: number of covariates already in A
#pB: number of covariates obtained from linkage process (XB)
N = nrow(XB)
n = nrow(data_naive)
p = pA + pB
Ts <- data_naive[,1]
event <- data_naive[,2]
XA <- as.matrix(data_naive[,3:(pA+2)])
Z <- as.matrix(data_naive[,(pA+3):(p+2)])
XB <- XB
betaA <- beta[1:pA]
betaB <- beta[(pA+1):p]
Y <- cbind(XA,Z)
muZ <- exp(Z%*% betaB)
psiZ <- Z*matrix(rep(exp(Z%*% betaB),pB), ncol = pB)
muXA <- exp(XA%*% betaA)
psiXA <- XA*matrix(rep(exp(XA%*% betaA),pA), ncol = pA)
if (Q == 1){
XB <- as.matrix(XB[,1:pB])
mean.muXB <- mean(exp(XB%*%betaB))
mean.psiXB <- colMeans((XB*matrix(rep(exp(XB %*% betaB),pB),ncol = pB)))
temp1 <- Z/alpha - (1/alpha-1)*matrix(rep(colMeans(XB),n), nrow = n, byrow = TRUE)
temp1 <- cbind(XA, temp1)
dat <- cbind(Ts, temp1)[which(event==1),]
## Estimating equation
ee <- apply(dat, 1,
function(df){
df <- matrix(df, nrow = 1)
ts <- df[, 1]
t1R <- df[, 2:ncol(df)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
t2R <- sum(muXA[risk]*muZ[risk])/alpha-(1/alpha-1)*mean.muXB*sum(muXA[risk])
t3A <- colSums(matrix(psiXA[risk,]*muZ[risk], ncol = pA))/alpha - (1/alpha-1)*mean.muXB*colSums(matrix(psiXA[risk,], ncol = pA))
t3B <- colSums(matrix(psiZ[risk,]*muXA[risk], ncol = pB))/alpha - (1/alpha-1)*mean.psiXB*sum(muXA[risk])
t3R <- c(t3A, t3B)
return((t1R - t3R / t2R))
}) %>%
matrix(nrow = p)%>%
rowSums()
}
else if(Q>1){
alpha.Q <- matrix(0, ncol = 1, nrow = n)
meanXB.Q <- matrix(0, ncol = pB, nrow = n)
mean.muXB.Q <- matrix(0, ncol = 1, nrow = n)
mean.psiXB.Q <- matrix(0, ncol = pB, nrow = n)
for (q in 1:Q) {
alpha.Q[which(data_naive$block == q),] <- alpha[q]
XB.q <- as.matrix(XB[which(XB$block == q),1:pB])
n.q <- length(which(data_naive$block == q))
meanXB.Q[which(data_naive$block == q),] <- matrix(rep(colMeans(XB.q),n.q), nrow = n.q, byrow = TRUE)
mean.muXB.Q[which(data_naive$block == q),] <- mean(exp(XB.q%*%betaB))
mean.psiXB.Q[which(data_naive$block == q),] <- matrix(rep(colMeans((XB.q*matrix(rep(exp(XB.q %*% betaB),pB),ncol =pB))),n.q), nrow = n.q, byrow = TRUE)
}
temp1 <- Z/matrix(rep(alpha.Q,pB),ncol = pB) - matrix(rep(1/alpha.Q-1,pB),ncol = pB)*meanXB.Q
temp1 <- cbind(XA, temp1)
temp2 <- (muXA*muZ)/alpha.Q - (1/alpha.Q-1)*mean.muXB.Q*muXA
temp3A <- psiXA*matrix(rep(muZ, pA), ncol = pA)/matrix(rep(alpha.Q,pA),ncol = pA)- matrix(rep(1/alpha.Q-1,pA),ncol = pA)*matrix(rep(mean.muXB.Q, pA), ncol = pA)*psiXA
temp3B <- psiZ*matrix(rep(muXA, pB), ncol = pB)/matrix(rep(alpha.Q,pB),ncol = pB) - matrix(rep(1/alpha.Q-1,pB),ncol = pB)*mean.psiXB.Q*matrix(rep(muXA, pB), ncol = pB)
dat <- cbind(Ts, temp1)[which(event==1),]
## Estimating equation
ee <- apply(dat, 1,
function(df){
df <- matrix(df, nrow = 1)
ts <- df[, 1]
t1R <- df[, 2:ncol(df)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
t2R <- sum(temp2[risk])
t3A <- colSums(as.matrix(temp3A[risk,]))
t3B <- colSums(as.matrix(temp3B[risk,]))
t3R <- c(t3A, t3B)
return((t1R - t3R / t2R))
}) %>%
matrix(nrow = p)%>%
rowSums()
}
return(ee)
}
#3. Estimating equation solving
coxph_aee <- function(data_naive, XB, pA, pB, alpha, Q, maxiter = 20){
f <- function(x){
aee(beta = x, data_naive=data_naive, XB = XB, pA = pA, pB = pB, alpha = alpha, Q = Q)
}
fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
beta <- fit_manual$root
converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge))
}
library(survival)
# n = 1000
# N = 2000
# pA = 3
# pB = 1
# p = pA+pB
# beta = matrix(rep(0.5,p), nrow = p)
# rho = 0.75
# alpha = 0.85
# block = 3
nvec = c(26,1348,5,57,1552)
Nvec = c(26,1348,5,57,1552)
pA = 3 #fixed
pB = 1 #fixed
p = pA+pB
alpha = c(5,6,7,8,9)/9
Q = 5
beta = matrix(c(0.064, -0.133, 0.746, -0.35), nrow = p)
rho = 0.55
data <- generate_full_mixed(Q, nvec, Nvec, alpha, pA, pB, beta, rho)
data_true <- data$data_true
data_naive <- data$data_naive
XB = data$XB
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
fit_true
fit_naive <- coxph(Surv(Time,delta)~.,data = data_naive[,1:(p+2)])
fit_naive
fit_aee <- coxph_aee(data_naive, XB, pA, pB, alpha = alpha, Q=5, maxiter = 20 )
fit_aee$coef
library(mvtnorm)
library(glmnet)
library(matrixStats)
library(clue)
# This function generate survival data
# Sample size: N
# Number of Gaussian covariates: p
# True values of coeficients: beta
# Proportion of non-censoring: rho
generate_surv_cont= function(N, p, beta, rho ){
if (p==2){
corX <- diag(p)
mX <- c(0,2)
X <- mvtnorm::rmvnorm(N, mean=mX, sigma = corX)
}else{
corX <- diag(p)
mX <- rep(0,p)
X <- mvtnorm::rmvnorm(N, mean=mX, sigma = corX)
}
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored: Do you think this can cause problem?
C = quantile(Tt, probs = rho)
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Surival data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# Generate surival time with two binary covariates
generate_surv_binary <- function(N, p, beta, rho ){
if (p==1){
X <- matrix(rbinom(N, size = 1, prob = 0.7), ncol = p)
}else if (p==2){
X <- matrix(c(rbinom(N, size = 1, prob = 0.7), rbinom(N, size = 1, prob = 0.5)), ncol = p)
}
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored
C = quantile(Tt, probs = rho)
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# Genrate survival time with one normal covariate and one binary covariate
generate_surv_mixed = function(N, p, beta, rho ){
# Two first continuous variables, then all binary
X1 <- rnorm(N,75,13)
X2 <- rbinom(N,size = 1, prob = 0.53)
X3 <- rbinom(N,size = 1, prob = 0.145)
X4 <- rbinom(N,size = 1, prob = 0.11)
X <- as.matrix(cbind(X1, X2, X3, X4))
# Time to event variable
U <- runif(N,0,1)
Tt = -log(U)/exp((X%*%beta))  #lambda=1
# Constant right cersored:
C = quantile(Tt, probs = rho)
#C = 1.777907
Time = pmin(Tt, C)
delta = as.numeric(Tt <= C)
#print(sum(delta)/n)
# Surival data
surv_data= data.frame(Time, delta, X)
colnames(surv_data)=c('Time','delta',paste("X", 1:p, sep = ""))
return(surv_data)
}
# This function generates two databases A and B with
# n: Number on individuals in A
# N: Number of individuals in B
# p: Number of covariates
# beta: True coefficients
# rho: Proportion of non-censoring
# alpha_q: Record linkage quality
generate_linked_cont <- function(n, N, p, beta, rho , alpha_q){
# Survival data (Database B)
surv_data <- generate_surv_cont(N,p, beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_linked_binary <- function(n, N, p, beta, rho , alpha_q){
# Survival data
surv_data <- generate_surv_binary(N,p,beta, rho)
X <- surv_data[,3:ncol(surv_data)]
XB <- as.matrix(X, ncol = p)
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2]
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
data_naive <- cbind(data_A, X_naive)
trueLink_id <- diag(L)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
##################################### 1 block ###########################
generate_1block_mixed <- function(n, N, pA, pB, beta, rho, alpha_q, block){
blockA = rep(block, n)
blockB = rep(block, N)
p = pA+ pB
# Survival data (Database B)
surv_data <- generate_surv_mixed(N, p, beta, rho)
X <- as.matrix(surv_data[,3:ncol(surv_data)])
XB <- as.matrix(X, ncol = p) #Only covariates
###### True-link data: The first n individual from B
data_true <- surv_data[1:n,]
###### Linked data
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Lvec <- sapply(1:n,FUN = function(i){
prob = rep((1-alpha_q)/N,N)
prob[i] = alpha_q + (1-alpha_q)/N #Probability of True links
return(sample(1:N, size = 1, prob = prob))
})
Lvec
L = matrix(0, nrow = n, ncol =N)
L[cbind(1:n, Lvec)] = 1
X_naive <- L %*% XB
# Naive data
data_naive <- cbind(data_A, X_naive, block= blockA)
data_naive[,3:(pA+2)] <- data_true[, 3:(pA+2)]
XB <- as.data.frame(cbind(X, block = blockB))
XB <- XB[,(pA+1): (p+1)]
trueLink_id <- cbind(diag(L), block = blockA)
return(list(data_true = data_true, data_A = data_A,   XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
generate_full_mixed <- function(Q, nvec, Nvec, alpha, pA, pB, beta, rho){
# Q >= 2
n = nvec[1]
N = Nvec[1]
alpha_q = alpha[1]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho , alpha_q, block = 1)
data_true <- data_block$data_true
data_naive <- data_block$data_naive
XB <- data_block$XB
trueLink_id <- data_block$trueLink_id
for (i in 2:Q){
n = nvec[i]
N = Nvec[i]
alpha_q = alpha[i]
data_block <- generate_1block_mixed(n, N, pA, pB, beta, rho, alpha_q, block = i)
data_true <- rbind(data_true,data_block$data_true)
data_naive <- rbind(data_naive,data_block$data_naive)
XB <- rbind(XB,data_block$XB)
trueLink_id <- rbind(trueLink_id, data_block$trueLink_id)
}
return(list(data_true = data_true,  XB = XB, data_naive = data_naive, trueLink_id = trueLink_id))
}
library(survival)
# n = 1000
# N = 2000
# pA = 3
# pB = 1
# p = pA+pB
# beta = matrix(rep(0.5,p), nrow = p)
# rho = 0.75
# alpha = 0.85
# block = 3
nvec = c(26,1348,5,57,1552)
Nvec = c(26,1348,5,57,1552)
pA = 3 #fixed
pB = 1 #fixed
p = pA+pB
alpha = c(5,6,7,8,9)/9
Q = 5
beta = matrix(c(0.064, -0.133, 0.746, -0.35), nrow = p)
rho = 0.55
data <- generate_full_mixed(Q, nvec, Nvec, alpha, pA, pB, beta, rho)
data_true <- data$data_true
data_naive <- data$data_naive
XB = data$XB
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
fit_true
3535-1792
170*8/9+11*7/9+1500*6/9+58*5/6+4*4/9
(170*8/9+11*7/9+1500*6/9+58*5/6+4*4/9)/1743
library(fastLink)
dfA
##########################################################################
setwd("C:\\Users\\thhvo.BCOM\\Dropbox\\R_program\\First_paper\\Mixed\\Results")
load("1028_1000s_resv1.RData")
val <- getArray(res)
library(simsalapar)
library(stringr)
library(reshape2)
library(dplyr)
library(tidyr)
library(tidyverse)
library(remotes)
val <- getArray(res)
dimnames(val)
names(dimnames(val))=c("methods", "error3","n.sim")
dimnames(val)[[1]]=list("TPR-5 mixed", "PPV-5 mixed", "converge mixed",
"TPR-5 binary", "PPV-5 binary", "converge binary",
"TPR binary2", "PPV binary2",
"TPR binary3", "PPV binary3",
"time mixed", "time binary", "time binary2", "time binary3")
df <- array2df(val)
df$methods = factor(df$methods)
df$error3 =  factor(df$error3)
df_converge = subset(df, df$methods == "converge mixed"|df$methods == "converge binary")
mean_converge <- df_converge %>% group_by(error3,methods) %>% dplyr::summarize(
B = n(),
Mean = mean(value, na.rm = TRUE)
)
mean_converge
df_time = subset(df, df$methods == "time mixed"|df$methods == "time binary"|df$methods == "time binary2")
mean_time <- df_time %>% group_by(error3,methods) %>% dplyr::summarize(
B = n(),
Mean = mean(value, na.rm = TRUE),
Sd = sd(value, na.rm = TRUE)
)
mean_time
df_time = subset(df, df$methods == "time mixed"|df$methods == "time binary"|df$methods == "time binary2"|df$methods == "time binary3")
mean_time <- df_time %>% group_by(error3,methods) %>% dplyr::summarize(
B = n(),
Mean = mean(value, na.rm = TRUE),
Sd = sd(value, na.rm = TRUE)
)
mean_time
df_TPRPPV = subset(df, df$methods == "TPR-5 mixed"|df$methods == "PPV-5 mixed"|
df$methods == "TPR-5 binary"|df$methods == "PPV-5 binary"|
df$methods == "TPR binary2"|df$methods == "PPV binary2"|
df$methods == "TPR binary3"|df$methods == "PPV binary3")
mean_TPRPPV <- df_TPRPPV %>% group_by(error3,methods) %>% dplyr::summarize(
B = n(),
Mean = mean(value, na.rm = TRUE),
Sd = sd(value, na.rm = TRUE)
)
mean_TPRPPV
View(mean_TPRPPV)
fastLink
library(fastLink)
fastLink
emlinkMARmov
View(mean_time)
