x1 <- seq(-2, 4, by = .5)
round(x1)
round(x1)
round(.5 + -2:4)
round(5)
round(5,6)
x2 <- pi * 100^(-1:3)
round(x2, 3)
x2
signif(x2, 3)
x1 <- seq(-2, 4, by = .5)
x1
round(x1)
.5 + -2:4
.5 + -2:8
round(.5 + -2:8)
round(.5 + -2:10)
round(.5*10)
round(.6*10)
round(.6*11)
.6*11
# sub-function: Making error for one binary vector x
makeError <- function(x,error){
#x is a column of B
#error is a proportion of error
nE  = round(length(x)*error)
index = sample(1:length(x), nE)
x[index] = 1-x[index]
return(x)
}
# This function is used to generate two database for linkage
# Database A with nA units and database B with nB units
# K: number of matching variables
# prevalence: frequency of low prevalence values
# error: proportion of error
# min_prev: minimum bound for the frequency of generated data
generate_data <- function(nA, nB, K, prevalence, error, min_prev = 0.01){
# First database A
datA = matrix(0, nrow = nA, ncol = K+1)
datA[,K+1] = 1:nA #id
conditionA = TRUE
while (conditionA){
datA[,1:K] = sapply(prevalence, function(x){rbinom(n=nA, size = 1,prob = x)})
conditionA = (sum(colSums(datA[,1:K]/nA) >= min_prev) < K)
}
datA = data.frame(datA)
colnames(datA)=c(paste("R", 1:K, sep = ""),"id")
conditionB = TRUE
while (conditionB) {
# Second database B
idAB <- sample(1:nA,nB) #ident in A appearing in B
datB <- datA[idAB,]
# Make error for B
datB[,1:K]= apply(datB[,1:K], MARGIN = 2, FUN = makeError, error = error)
conditionB = (sum(colSums(datB[,1:K]) >= 1) < K)
}
return(list(dataA=datA, dataB = datB, prev = prevalence))
}
makeError(1:6, 0.2)
6*0.2
round(1.2)
sample(1:6,1)
generate_data(4,5,2,2,0.2)
generate_data(4,5,2,2,0.2,0.01)
x <- list(a = 1:10, beta = exp(-3:3), logic = c(TRUE,FALSE,FALSE,TRUE))
x
sapply(x, quantile)
# This function is used to generate two database for linkage
# Database A with nA units and database B with nB units
# K: number of matching variables
# prevalence: frequency of low prevalence values
# error: proportion of error
# min_prev: minimum bound for the frequency of generated data
generate_data <- function(nA, nB, K, prevalence, error, min_prev = 0.01){
# First database A
datA = matrix(0, nrow = nA, ncol = K+1)
datA[,K+1] = 1:nA #id
conditionA = TRUE
while (conditionA){
datA[,1:K] = sapply(prevalence, function(x){rbinom(n=nA, size = 1,prob = x)})
conditionA = (sum(colSums(datA[,1:K]/nA) >= min_prev) < K)
}
datA = data.frame(datA)
colnames(datA)=c(paste("R", 1:K, sep = ""),"id")
conditionB = TRUE
while (conditionB) {
# Second database B
idAB <- sample(1:nA,nB) #ident in A appearing in B
datB <- datA[idAB,]
# Make error for B
datB[,1:K]= apply(datB[,1:K], MARGIN = 2, FUN = makeError, error = error)
conditionB = (sum(colSums(datB[,1:K]) >= 1) < K)
}
return(list(dataA=datA, dataB = datB, prev = prevalence))
}
generate_data(8,5,2,2,0.2,0.01)
install.packages("doParallel")
library(doParallel)
# The proposed 3 categorical comparison for binary matching variables
compare3 <- function(datA, datB, K){
compare1 <- function(k, datA, datB, K){
XA.k = datA[,k]
XB.k = datB[,k]
temp = expand.grid(XA.k, XB.k)
if (k == (K+1)){
gamma.k = as.numeric(temp[,1]==temp[,2])
}else{
gamma.k = temp[,1]+temp[,2]
}
return(gamma.k)
}
comp_mat = sapply(1:(K+1), FUN = compare1, datA = datA, datB = datB, K =K)
return(comp_mat)
}
x <- seq(0, 10, length.out = 100)
y <- seq(-1, 1, length.out = 20)
d1 <- expand.grid(x = x, y = y)
d1
round == FALSE
XA = matrix(rexp(5*3,rate = 0.2),ncol = 3)
View(XA)
XA1 = XA[1:3,]
XA2  = XA[-(1:3),]
View(XA1)
View(XA2)
library(clue)
## Different record linkage methods corresponding to proposed comparison approach
FS_gamma <- function(datA, datB, K,  tol = 1e-6, maxits = 500){
comp_mat = compare_abs(datA = datA,datB = datB, K =K)
nB =  nrow(datB)
nA =  nrow(datA)
fit = EM_hurdle_gammaK(X = comp_mat[,1:K],K = K,nB = nB, tol = tol, maxits = maxits)
g = fit$g
converge = fit$converge
## Threshold
indM = which(comp_mat[,K+1]==1)
gm = g[indM]
n_true = sum(gm>0.5)
n_predict = sum(g>0.5)
n_matches = nB
TPR_5 = n_true/n_matches
if (n_predict >0){
PPV_5 = n_true/n_predict
}else{
PPV_5 = 1
}
return(c(TPR_5, PPV_5, converge))
}
library(simsalapar)
