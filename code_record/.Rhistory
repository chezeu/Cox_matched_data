Q_I = matrix(0,lenght(n),lenght(m))
lenght(n)
length(n)
length(m)
Q_I = matrix(0,length(n),length(m))
Q_I
# BLOCK MATRIX
n_A= nrow(datasetA)
n_B= nrow(datasetB)
Q = matrix(0, nrow=n_A, ncol = n_B )
name_A = fnameA[1]
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
Q_I = matrix(0,length(n),length(m)) # block matrix
n
m
which(prob_match$.x==n & prob_match==m)
n
which(prob_match$.x == n)
which(prob_match$.x == n & prob_match == m)
which(prob_match$.x == n)
which(prob_match$.x == n)
prob_match$mpost[ which(prob_match$.x == n) ]
Q_I =  mprob
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
as.matrix(mprob)
Q_I
Q_I =  mprob
Q_I
Q_I = matrix(0,length(n),length(m)) # block matrix
matrix(mprob)
name_A = fnameA[1]
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
Q_I
Q = NULL # general matrix
Q = rbind(Q,Q_I)
Q
View(p_compar)
n
new_dataA[1,]
new_dataA[1,]$idA
Q
Q = matrix(0,nrow = n_A,ncol = n_B) # general matrix
name_A = fnameA[1]
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[1,]$idA
idA
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
mprob
Q_I = matrix(mprob,length(n),length(m)) # block matrix
Q_I
Q_I = matrix(mprob,length(n),length(n_B)) # block matrix
Q_I
Q[idA, ]
m
Q[idA, 1] =   Q_I
Q
View(Q)
Q = matrix(0,nrow = n_A,ncol = n_B) # general matrix
name_A = fnameA[1]
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[1,]$idA
idB = new_dataB[1,]$idB
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
Q[idA, idB] =   Q_I
View(Q)
name_A = fnameA[2]
name_A
n =  which(datasetA$fname_c1==name_A)
n
m = which(datasetB$fname_c1==name_A)
m
idA = new_dataA[2,]$idA
n
View(new_dataA)
View(new_dataB)
idA = new_dataA[2,]$idA
idB = new_dataB[2,]$idB
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
mprob
n
Q_I = matrix(mprob,length(n),length(m)) # block matrix
Q_I
idA
idB
Q[idA, idB] =   Q_I
View(Q)
name_A = fnameA[3]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
View(datasetA)
View(datasetB)
idA = new_dataA[n,]$idA
idA
n
datasetB$idB = 1:nrow(datasetB) # new data B
datasetA$idA = 1:nrow(datasetA)
datasetB$idB = 1:nrow(datasetB) # new data B
idA = new_dataA[n,]$idA
idA
idA = datasetA[n,]$idA
idA
idA = datasetA[n,]$idA
idA
View(datasetA)
idA = new_dataA[n,]$idA
idA
n
(i+length(n))
length(n)
i
(3+length(n))
idA = new_dataA[3,(3+length(n))]$idA
3:(3+length(n))
new_dataA[3:(3+length(n)),]$idA
name_A
n
new_dataA[3:(3+length(n-1)),]$idA
new_dataA[3:(3+length(n))-1,]$idA
new_dataA[3:(3+length(n)-1),]$idA
new_dataB[3:(3+length(m)-1),]$idB
prob_match$mpost[ which(prob_match$.x == n) ]
n
which(prob_match$.x == n
)
name_A
n =  which(datasetA$fname_c1==name_A)
n
m = which(datasetB$fname_c1==name_A)
m
idA = new_dataA[3:(3+length(n)-1),]$idA
idB = new_dataB[3:(3+length(m)-1),]$idB
n
m
prob_match$mpost[ which(prob_match$.x == n) ]
n
length(n)
m
n
prob_match$mpost[ which(prob_match$.x == n[1]) ]
Q_I[1,] = mprob
Q_I
mprod = prob_match$mpost[ which(prob_match$.x == n[1]) ]
Q_I[1,] = mprob
Q_I
n[1]
prob_match$mpost[ which(prob_match$.x == n[1]) ]
mprod = prob_match$mpost[ which(prob_match$.x == n[1]) ]
Q_I
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
Q_I[1,] = mprob
Q_I
mprod = prob_match$mpost[ which(prob_match$.x == n[1]) ]
mprob = prob_match$mpost[ which(prob_match$.x == n[1]) ]
Q_I[1,] = mprob
Q_I
n[2]
mprob = prob_match$mpost[ which(prob_match$.x == n[2]) ]
mprob
Q_I[2,] = mprob
Q_I
if (length(n)!=1){
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
}
Q_I
idA
idB
Q[idA, idB] =   Q_I
View(Q)
name_A = fnameA[4]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[4:(4+length(n)-1),]$idA
idB = new_dataB[4:(4+length(m)-1),]$idB
idA
n
m
length(n)
idA
library(RecordLinkage)
library(plyr)
library(dplyr)
library(reclin2)
data("RLdata500")
data("RLdata10000")
s1 <- 1:100
s2 <- 1:100
datasetB <- rbind( RLdata10000[s2,],RLdata500[s1,])
datasetA <- RLdata500[s1,]
var_block= "fname_c1"
# pairs with blocking variable
p <- pair_blocking (datasetA, datasetB,var_block , FALSE)
#p <- print(p)
#  comparison matrix of pairs
p <- compare_pairs ( p, on= c("fname_c1","fname_c2","lname_c1","lname_c2","by","bm","bd"),
comparators = list(fname_c2 = jaro_winkler(),
lname_c1 = jaro_winkler(), lname_c2  = jaro_winkler() ) )
#p <- print(p)
## classification
p0=1/length(datasetB)
model <- problink_em ( ~ fname_c1+fname_c2 +lname_c1 +lname_c2 +by +bm+bd , data=p,
mprobs0 = list(0.9),uprobs0 = list(0.02),p0 = p0 ,tol = 1e-05,
mprob_max = 0.999, uprob_min = 1e-04)
#print(model)
p_compar <- predict(model, p, type ="mpost", add = TRUE, binary = TRUE)
prob_match <- p_compar[,c(1:2,10)]
# generate the blocks A
fnameA = unique(new_dataA$fname_c1) # number of blocks A with variable fname_c1
p1 = unique( prob_match$.x)
new_dataA = datasetA[p1,]
datasetA$idA = 1:nrow(datasetA)
# generate the blocks B
VEC_idB = vector()
for (i in 1: length (fnameA)) {
ni = which(datasetB$fname_c1 == fnameA[i])
VEC_idB = c(VEC_idB,ni)
}
datB2= datasetB[VEC_idB,]
n=as.numeric(VEC_idB)
rest_B = datasetB[-n,]
new_dataB = rbind(datB2, rest_B)
datasetB$idB = 1:nrow(datasetB) # new data B
# generate the blocks A
p1 = unique( prob_match$.x)
new_dataA = datasetA[p1,]
fnameA = unique(new_dataA$fname_c1) # number of blocks A with variable fname_c1
datasetA$idA = 1:nrow(datasetA)
# generate the blocks B
VEC_idB = vector()
for (i in 1: length (fnameA)) {
ni = which(datasetB$fname_c1 == fnameA[i])
VEC_idB = c(VEC_idB,ni)
}
datB2= datasetB[VEC_idB,]
n=as.numeric(VEC_idB)
rest_B = datasetB[-n,]
new_dataB = rbind(datB2, rest_B)
datasetB$idB = 1:nrow(datasetB) # new data B
library(RecordLinkage)
library(plyr)
library(dplyr)
library(reclin2)
data("RLdata500")
data("RLdata10000")
s1 <- 1:100
s2 <- 1:100
datasetB <- rbind( RLdata10000[s2,],RLdata500[s1,])
datasetA <- RLdata500[s1,
var_block= "fname_c1"
linkage_function<- function(datasetA,datasetB,var_block){
# pairs with blocking variable
p <- pair_blocking (datasetA, datasetB,var_block , FALSE)
#p <- print(p)
#  comparison matrix of pairs
p <- compare_pairs ( p, on= c("fname_c1","fname_c2","lname_c1","lname_c2","by","bm","bd"),
comparators = list(fname_c2 = jaro_winkler(),
lname_c1 = jaro_winkler(), lname_c2  = jaro_winkler() ) )
#p <- print(p)
## classification
p0=1/length(datasetB)
model <- problink_em ( ~ fname_c1+fname_c2 +lname_c1 +lname_c2 +by +bm+bd , data=p,
mprobs0 = list(0.9),uprobs0 = list(0.02),p0 = p0 ,tol = 1e-05,
mprob_max = 0.999, uprob_min = 1e-04)
#print(model)
p_compar <- predict(model, p, type ="mpost", add = TRUE, binary = TRUE)
prob_match <- p_compar[,c(1:2,10)]
return(prob_match=prob_match)
}
library(RecordLinkage)
library(plyr)
library(dplyr)
library(reclin2)
data("RLdata500")
data("RLdata10000")
s1 <- 1:100
s2 <- 1:100
datasetB <- rbind( RLdata10000[s2,],RLdata500[s1,])
datasetA <- RLdata500[s1,]
var_block= "fname_c1"
# pairs with blocking variable
p <- pair_blocking (datasetA, datasetB,var_block , FALSE)
#  comparison matrix of pairs
p <- compare_pairs ( p, on= c("fname_c1","fname_c2","lname_c1","lname_c2","by","bm","bd"),
comparators = list(fname_c2 = jaro_winkler(),
lname_c1 = jaro_winkler(), lname_c2  = jaro_winkler() ) )
## classification
p0=1/length(datasetB)
model <- problink_em ( ~ fname_c1+fname_c2 +lname_c1 +lname_c2 +by +bm+bd , data=p,
mprobs0 = list(0.9),uprobs0 = list(0.02),p0 = p0 ,tol = 1e-05,
mprob_max = 0.999, uprob_min = 1e-04)
p_compar <- predict(model, p, type ="mpost", add = TRUE, binary = TRUE)
prob_match <- p_compar[,c(1:2,10)]
library(RecordLinkage)
library(plyr)
library(dplyr)
library(reclin2)
data("RLdata500")
data("RLdata10000")
s1 <- 1:100
s2 <- 1:100
datasetB <- rbind( RLdata10000[s2,],RLdata500[s1,])
datasetA <- RLdata500[s1,]
var_block= "fname_c1"
linkage_function<- function(datasetA,datasetB,var_block){
# pairs with blocking variable
p <- pair_blocking (datasetA, datasetB,var_block , FALSE)
#p <- print(p)
#  comparison matrix of pairs
p <- compare_pairs ( p, on= c("fname_c1","fname_c2","lname_c1","lname_c2","by","bm","bd"),
comparators = list(fname_c2 = jaro_winkler(),
lname_c1 = jaro_winkler(), lname_c2  = jaro_winkler() ) )
#p <- print(p)
## classification
p0=1/length(datasetB)
model <- problink_em ( ~ fname_c1+fname_c2 +lname_c1 +lname_c2 +by +bm+bd , data=p,
mprobs0 = list(0.9),uprobs0 = list(0.02),p0 = p0 ,tol = 1e-05,
mprob_max = 0.999, uprob_min = 1e-04)
#print(model)
p_compar <- predict(model, p, type ="mpost", add = TRUE, binary = TRUE)
prob_match <- p_compar[,c(1:2,10)]
return(prob_match=prob_match)
}
prob_match = linkage_function (datasetA,datasetB,var_block)
# generate the blocks A
p1 = unique( prob_match$.x)
new_dataA = datasetA[p1,]
View(new_dataA)
fnameA = unique(new_dataA$fname_c1) # number of blocks A with variable fname_c1
datasetA$idA = 1:nrow(datasetA)
View(datasetA)
# generate the blocks B
VEC_idB = vector()
for (i in 1: length (fnameA)) {
ni = which(datasetB$fname_c1 == fnameA[i])
VEC_idB = c(VEC_idB,ni)
}
datB2= datasetB[VEC_idB,]
n=as.numeric(VEC_idB)
rest_B = datasetB[-n,]
new_dataB = rbind(datB2, rest_B)
datasetB$idB = 1:nrow(datasetB) # new data B
View(new_dataB)
View(datasetB)
# BLOCK MATRIX
n_A= nrow(datasetA)
n_B= nrow(datasetB)
Q = matrix(0,nrow = n_A,ncol = n_B) # general matrix
k=0
name_A = fnameA[1]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[1:(1+length(n)-1),]$idA
new_dataA
# generate the blocks A
p1 = unique( prob_match$.x)
new_dataA = datasetA[p1,]
fnameA = unique(new_dataA$fname_c1) # number of blocks A with variable fname_c1
new_dataA$idA = 1:nrow(new_dataA)
# generate the blocks B
VEC_idB = vector()
for (i in 1: length (fnameA)) {
ni = which(datasetB$fname_c1 == fnameA[i])
VEC_idB = c(VEC_idB,ni)
}
datB2= datasetB[VEC_idB,]
n=as.numeric(VEC_idB)
rest_B = datasetB[-n,]
new_dataB = rbind(datB2, rest_B)
new_dataB$idB = 1:nrow(new_dataB) # new data B
View(new_dataA)
View(new_dataB)
# BLOCK MATRIX
n_A= nrow(datasetA)
n_B= nrow(datasetB)
Q = matrix(0,nrow = n_A,ncol = n_B) # general matrix
k=0
name_A = fnameA[1]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[1:(1+length(n)-1),]$idA
idB = new_dataB[1:(1+length(m)-1),]$idB
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
Q_I
if (length(n)!=1){
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
}
length(n)
k
Q[idA+k, idB+k] =   Q_I
View(Q)
k=k+length(n)
name_A = fnameA[2]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
View(prob_match)
idA = new_dataA[2:(2+length(n)-1),]$idA
idB = new_dataB[2:(2+length(m)-1),]$idB
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
mprob
Q_I = matrix(mprob,length(n),length(m)) # block matrix
if (length(n)!=1){
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
}
idA+k
k=k+length(n)-1
k+length(n)-1
length(n)
k
k=0
k=k+length(n)-1
Q[idA+k, idB+k] =   Q_I
View(Q)
k=k+length(n)-1
name_A = fnameA[3]
name_A
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[3:(3+length(n)-1),]$idA
idB = new_dataB[3:(3+length(m)-1),]$idB
if (length(n)=1){
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
}
length(n)
if (length(n)=1){
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
}
if (length(n)=1){
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
}
n
length(n)
if (length(n)=1){
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
}
if (length(n)==1){
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
}
n
m
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
Q_I
if (length(n)!=1){
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
}
k
idA
idB
Q[idA+k, idB+k] = Q_I
View(Q)
k=k+length(n)-1
length(n)
name_A = fnameA[4]
name_A
name_A = fnameA[4]
n =  which(datasetA$fname_c1==name_A)
m = which(datasetB$fname_c1==name_A)
idA = new_dataA[4:(4+length(n)-1),]$idA
idB = new_dataB[4:(4+length(m)-1),]$idB
mprob = prob_match$mpost[ which(prob_match$.x == n) ]
Q_I = matrix(mprob,length(n),length(m)) # block matrix
if (length(n)!=1){
Q_I = matrix(0,nrow = length(n), ncol = length(m) )
for (j in 1: length(n)) {
mprob = prob_match$mpost[ which(prob_match$.x == n[j]) ]
Q_I[j,] = mprob
}
}
k
idA
idB
k
n
idB*k
Q[idA+k, idB*k] = Q_I
View(Q)
