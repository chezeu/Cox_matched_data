XB <- surv_data[,3:ncol(surv_data)]
X <- as.matrix(XB, ncol = p) #Only covariates
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
Q <-Matrix_function_sum(n,m,C,beta)
eXbeta <- exp(X%*% beta)
XeXbeta <- X*matrix(rep(exp(X%*% beta),p), ncol = p)
# somme des deux valeurs max
Z<-matrix(0, nrow = n, ncol = p)
for (k in 1:n) {
qk <- Q[k,]
k1<- which(qk==max(qk))
l1<-max(qk)
qk[k1]<-0
k2<-which(qk==max(qk))
if(length(k2)!=1){k2<-k2[1]}
qk[k1]<-l1
qkx <- (qk*X)[c(k1,k2),]
Z[k,]<- colSums(qkx)
}
Z
#### les sommes q*exp(beta x) pour tilfe_f
som1<- vector()
for (j in 1:n) {
qj <- Q[j,]
j1<- which(qj==max(qj))
l1<-max(qj)
qj[j1]<-0
j2<-which(qj==max(qj))
if(length(j2)!=1){j2<-j2[1]}
qj[j1]<-l1
qjx <- (qj*eXbeta)[c(j1,j2),]
som1[j] <- sum( qjx)
}
som1
###  les sommes pour tilde_g
som2<-matrix(0, nrow = n, ncol = p)
for (i in 1:n) {
qi <- Q[i,]
i1<- which(qi==max(qi))
l1<-max(qi)
qi[i1]<-0
i2<-which(qi==max(qi))
if(length(i2)!=1){i2<-i2[1]}
qi[i1]<-l1
qix <- (qi*XeXbeta)[c(i1,i2),]
som2[i,] <- colSums( qix)
}
som2
dat1 <- cbind(Ts,Z)[which(event==1),]
## Estimating equation
s <- matrix(0,nrow=nrow(dat1), ncol = p)
for (i in 1:nrow(dat1)) {
ts <- dat1[i, 1]
Z1R <- dat1[i,2:ncol(dat1)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
if(nrisk==1){
t2R <- som1[risk]
t3R <- matrix(som2, ncol = p)[risk,]
}else if(nrisk!=1){
t2R <- sum(som1[risk] )
t3R <- colSums(matrix(som2, ncol = p)[risk,] ) }
s[i,] <- (Z1R - (t3R/t2R))
}
s <- colSums(s)
return(H_w_sum2=s)
}
# ###########solve the equations
coxph_w_sum1 <- function(surv_data, p,maxiter = 20){
f <- function(x){
equa_W_sum1  (beta=x,n,m,C,surv_data)
}
fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
beta <- fit_manual$root
iterations <- fit_manual$iter
converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge,iterations=iterations))
}
coxph_w_sum2 <- function(surv_data, p,maxiter = 20){
f <- function(x){
equa_W_sum2  (beta=x,n,m,C,surv_data)
}
fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
beta <- fit_manual$root
iterations <- fit_manual$iter
converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list(coef = beta, converge = converge,iterations=iterations))
}
#############################
library(simsalapar)
library(doParallel)
doOne2d_w_sum1<- function(n,m,surv_data,C){
# Fixed parameters
p = 2
beta = matrix(c(0.5,-0.5), nrow = 2)
# surv_data<-Generate_data(m,n,beta)
XB <- surv_data[,3:ncol(surv_data)]
data_true <- surv_data[1:n,]
# Theoretical estimating equation for true and naive data
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
coef_true <- as.vector(fit_true$coefficients)
var_true <- diag(fit_true$var)
fit_w_sum1 <- coxph_w_sum1(surv_data, p,maxiter = 20)
coef_w_sum1 <- fit_w_sum1$coef
converge_w_sum1 <- fit_w_sum1$converge
return(list( coef_true=coef_true, coef_w_sum1=coef_w_sum1, converge_w_sum1=converge_w_sum1))
}
doOne2d_w_sum2<- function(n,m,surv_data,C){
p = 2
beta = matrix(c(0.5,-0.5), nrow = 2)
# surv_data<-Generate_data(m,n,beta)
XB <- surv_data[,3:ncol(surv_data)]
data_true <- surv_data[1:n,]
# Theoretical estimating equation for true and naive data
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
coef_true <- as.vector(fit_true$coefficients)
var_true <- diag(fit_true$var)
fit_w_sum2 <- coxph_w_sum2(surv_data, p,maxiter = 20)
coef_w_sum2 <- fit_w_sum2$coef
converge_w_sum2 <- fit_w_sum2$converge
return(list( coef_true=coef_true, coef_w_sum2=coef_w_sum2, converge_w_sum2=converge_w_sum2))
}
library(survival)
library(plyr)
library(dplyr)
library(rootSolve)
library(nleqslv)
library(mvtnorm)
library(glmnet)
library(matrixStats)
library(clue)
library(clue)
library(matrixStats)
library(klaR)
library(ludic)
library(doParallel)
library(RecordLinkage)
#########  multinomiale Q
Matrix_function_sum<-function(n,m,C,beta){
Q<-matrix(0,n,m)
#Lvec<-matrix(0,n,m)
for (i in 1:n) {
if(i!=1 & i!=n){
pro = rep(0,m)
pro[i] = C[1] #Probability of True links
pro[i+1]= C[3]
pro[i-1]=C[3]
Q[i,]<-pro
#Lvec[i,] <- rmultinom(1, size = 1, pro = pro)
}
if(i==1)  {
pro = rep(0,m)
pro[i] =  C[1] #Probability of True links
pro[i+1]= C[2]
pro[i+2]= C[3]
Q[i,]<-pro
#Lvec[i,] <- rmultinom(1, size = 1, pro = pro)
}
if(i==n){
pro = rep(0,m)
pro[i] = C[1] #Probability of True links
pro[i-1]=C[2]
pro[i-2]=C[3]
Q[i,]<-pro
# Lvec[i,] <- rmultinom(1, size = 1, pro= pro)
}
}
return(Q=Q)
}
##################
#1. Finding the risk set R(t) given some time t
GetRiskSet <- function(time_of_interest, time_vector, event_vector) {
return(which(((time_vector == time_of_interest & event_vector == 1) | (time_vector > time_of_interest))))
}
######################
# ####################initialisation########################
#cumulative function
Funct_lambda2<-function(lambda0,surv_data){
#lambda0<- rep(0.5,length(event))
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
l<- which(event==0)
lambda0[l]<-0
observe<- function(time_of_interest, time_vector, event_vector) {
return(which( (time_vector <= time_of_interest) ))
}
lambda2<-vector()
for (i in 1:n) {
vi<- observe(Ts[i], Ts, event)
lambda2[i]<- sum(lambda0[vi])
}
return(lambda2=lambda2)
}
### proba aposteriorie
Functio_prob<-function(beta0,lambda0,surv_data){
#beta0<- c(0.1,0.1)
#lambda0<- rep(0.5,length(event))
lambda2<-Funct_lambda2(lambda0,surv_data)
Q <-Matrix_function_sum(n,m,C,beta)
XB <- surv_data[,3:ncol(surv_data)]
X <- as.matrix(XB, ncol = p) #Only covariates
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
eXbeta0 <- exp(X%*% beta0)
XeXbeta0 <- X*matrix(rep(exp(X%*% beta0),p), ncol = p)
#pi(ij)
prob<-matrix(0,n,m)
for (i in 1:n) {
numerateur<-vector()
for (j in 1:m) {
numerateur[j]<- Q[i,j] * ( lambda0[i]*eXbeta0[j])^event[i] * exp(-lambda2[i]* eXbeta0[j] )
}
denominateur<-sum(numerateur)
prob[i,]<- numerateur/denominateur
}
prob
return( list(eXbeta0=eXbeta0,XeXbeta0=XeXbeta0,prob=prob))
}
################ estimations ###################################
#lambda0
Function_lambda0<-function(beta0,lambda0,surv_data){
init<-Functio_prob(beta0,lambda0,surv_data)
prob<- init$prob
eXbeta0<-init$eXbeta0
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
som1<-prob%*%eXbeta0
s <- vector()
for (i in 1:n) {
ts <- Ts[i]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
if(nrisk==0){
t2R<-1
}else if(nrisk==1){
t2R <- som1[risk]
}else if(nrisk!=1){
t2R <- sum( som1[risk] )
}
s[i] <- (1/t2R)*event[i]
}
return(s=s)
}
# equation estimente ########################
equa_estimate <- function(beta0,lambda0,surv_data) {
# Generate data
XB <- surv_data[,3:ncol(surv_data)]
X <- as.matrix(XB, ncol = p) #Only covariates
data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
init<-Functio_prob(beta0,lambda0,surv_data)
prob<- init$prob
eXbeta0<-init$eXbeta0
XeXbeta0<-init$XeXbeta0
#######les sommes pour Z
Z <- prob%*%X
#### les sommes q*exp(beta x) pour tilfe_f
som1<- prob%*%eXbeta0
###  les sommes pour tilde_g
som2<-prob%*%XeXbeta0
dat1 <- cbind(Ts, Z)[which(event==1),]
## Estimating equation
s <- matrix(0,nrow=nrow(dat1), ncol = p)
for (i in 1:nrow(dat1)) {
ts <- dat1[i, 1]
Z1R <- dat1[i,2:ncol(dat1)]
risk <- GetRiskSet(ts, Ts, event)
nrisk <- length(risk)
if(nrisk==1){
t2R <- som1[risk]
t3R <- matrix(som2, ncol = p)[risk,]
}else if(nrisk!=1){
t2R <- sum( som1[risk] )
t3R <- colSums(matrix(som2, ncol = p)[risk,] ) }
s[i,] <- (Z1R - t3R/t2R)
}
s <- colSums(s)
return(s=s)
}
# ###########solve the equation
coxph_estimate<- function(beta0,lambda0,surv_data,maxiter = 50){
f <- function(x){
equa_estimate  (beta0=x,lambda0,surv_data)
}
fit_manual <- nleqslv( c(0,0),f, method = c("Broyden", "Newton"))
beta0 <- fit_manual$x
iterations <- fit_manual$iter
converge <- as.numeric(( iterations< maxiter)& (fit_manual$scalex==1) )
#xstart <- matrix(rnorm(20,0,1), ncol = 2)
#Zero <-  searchZeros(xstart,f)
#fit_manual <- multiroot(f,start = rep(0,p), maxiter = maxiter)
# beta0 <- fit_manual$root
#iterations <- fit_manual$iter
#converge <- as.numeric((fit_manual$iter < maxiter)& !is.nan(fit_manual$estim.precis) & !is.na(fit_manual$estim.precis) & (fit_manual$estim.precis<1e-6))
return(list( beta0 = beta0,converge =converge) )
}
###iterrations###########################################
#valeurs initials
Func_itteration<-function(beta0,lambda0,surv_data,tol= 1e-6,maxits = 500){
#data_true <- surv_data[1:n,]
data_A <- surv_data[1:n,1:2] #Survival time and censored indicator
Ts <-as.matrix( data_A[,1])
event <- data_A[,2]
it = 0
converge = FALSE
while ((!converge) & (it < maxits)){
#expectation
lambda2<-Funct_lambda2(lambda0,surv_data)
init<-Functio_prob(beta0,lambda0,surv_data)
prob<- init$prob
lambda0.old<-lambda0
beta0.old<-beta0
lambda0<-Function_lambda0(beta0=beta0.old,lambda0=lambda0.old,surv_data)
#maximization
estime<-coxph_estimate(beta0=beta0.old,lambda0=lambda0.old,surv_data,maxiter =50)
beta0<-estime$beta0
it = it + 1
converge <-  (abs(beta0.old -beta0)/ (beta0.old+0.01))[1] < tol &&
(abs(beta0.old -beta0)/ (beta0.old+0.01))[2] < tol
if (it == maxits) {
cat("WARNING! NOT CONVERGENT!", "\n")
converge = FALSE
}else if(is.na(beta0[1]) & is.na(beta0[2])){
cat("WARNING! beta0 NOT AVAILABLE!", "\n")
converge = FALSE
}
}
return(list(beta0=beta0, lambda0=lambda0,prob=prob, converge= converge))
}
#############################################################
library(simsalapar)
library(doParallel)
doOne2d_estimate<- function(n,m,C,beta0,lambda0,surv_data){
#surv_data <- Generate_data(m,n,beta)
data_true <- surv_data[1:n,]
# Theoretical estimating equation for true data
fit_true <- coxph(Surv(Time,delta)~.,data = data_true)
coef_true <- as.vector(fit_true$coefficients)
var_true <- diag(fit_true$var)
fit_estimate  <- Func_itteration(beta0,lambda0,surv_data,tol= 1e-6,maxits = 100)
coef_estimate  <- fit_estimate$beta0
lambda0_estimate<-fit_estimate$lambda0
converge_estimate <- fit_estimate$converge
return(list( coef_true=coef_true, coef_estimate =coef_estimate,
converge_estimate =converge_estimate,lambda0_estimate=lambda0_estimate ))
}
sigma=1
alpha=1
C_sample=cbind(c(0.6,0.2,0.2),c(0.7,0.15,0.15),c(0.8,0.1,0.1))
m=20
n=15
p=2
nsim=20
beta=c(0.5,-0.5)
lambda0<- rep(0.5,n)
beta0<- c(0.1,0.1)
##############
scenarios=NULL
for (i in 1:ncol(C_sample)){
scenarios=rbind(scenarios,c(nsim,n,m,p,sigma,alpha,C_sample[,i]))
}
colnames(scenarios)=c("nsim","n","m", "p","sigma","alpha","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
###################
estimates_survival<- function(nsim,n,m,p,sigma,alpha,C,beta, lambda0,beta0){
coef_true_s<-matrix(0,nrow = nsim, ncol = p)
coef_naive_s<- matrix(0,nrow = nsim, ncol = p)
converge_naive <- vector()
coef_w_sum1_s<- matrix(0,nrow = nsim, ncol = p)
converge_w_sum1 <- vector()
coef_w_sum2_s<- matrix(0,nrow = nsim, ncol = p)
converge_w_sum2 <- vector()
coef_estimate_s <- matrix(0,nrow = nsim, ncol = p)
converge_estimate<- vector()
for (i in 1:nsim){
surv_data =Generate_data(m,n,beta)
g_naive <- doOne2d_equat_estimat(n,m,C,beta,surv_data)
coef_naive_s[i,] <- g_naive$coef_naive2
converge_naive[i] <- g_naive$converge_naive2
g_sum1 <- doOne2d_w_sum1 (n,m,surv_data,C)
coef_w_sum1_s[i,] <- g_sum1$coef_w_sum1
converge_w_sum1[i] <- g_sum1$converge_w_sum1
g_sum2 <- doOne2d_w_sum2 (n,m,surv_data,C)
coef_w_sum2_s[i,] <- g_sum2$coef_w_sum2
converge_w_sum2[i] <- g_sum2$converge_w_sum2
g_estim <- doOne2d_estimate (n,m,C,beta0,lambda0,surv_data)
coef_estimate_s [i,] <- g_estim$coef_estimate
converge_estimate [i] <- as.numeric (g_estim$converge_estimate)
coef_true_s[i,] <- g_estim$coef_true
}
return(list( coef_true_s1=coef_true_s[,1],coef_true_s2=coef_true_s[,2],
coef_naive_s1=coef_naive_s[,1], coef_naive_s2=coef_naive_s[,2], coef_w_sum1_s1=coef_w_sum1_s[,1],coef_w_sum1_s2=coef_w_sum1_s[,2],
coef_w_sum2_s1=coef_w_sum2_s[,1], coef_w_sum2_s2=coef_w_sum2_s[,2],
coef_estimate_s1=coef_estimate_s[,1],coef_estimate_s2=coef_estimate_s[,2],converge_naive=converge_naive, converge_w_sum1=converge_w_sum1,
converge_w_sum2=converge_w_sum2,converge_estimate= converge_estimate))  }
######################################
#results
set.seed(23)
for (i in (1:nrow(scenarios))){
nsim_sample=scenarios[i,1]
n_sample=scenarios[i,2]
m_sample=scenarios[i,3]
p_sample=scenarios[i,4]
sigma_sample=scenarios[i,5]
alpha_sample=scenarios[i,6]
C=vector()
C[1]=scenarios[i,7]
C[2]=scenarios[i,8]
C[3]=scenarios[i,9]
results_sample<- estimates_survival(nsim=nsim_sample,n=n_sample,m=m_sample,p=p_sample,sigma=sigma_sample,alpha=alpha_sample,C=C, beta, lambda0, beta0)
#boxplot(results_sample)
}
sigma=1
alpha=1
C_sample=cbind(c(0.6,0.2,0.2),c(0.7,0.15,0.15),c(0.8,0.1,0.1))
m=150
n=100
p=2
nsim=20
beta=c(0.5,-0.5)
lambda0<- rep(0.5,n)
beta0<- c(0.1,0.1)
##############
scenarios=NULL
for (i in 1:ncol(C_sample)){
scenarios=rbind(scenarios,c(nsim,n,m,p,sigma,alpha,C_sample[,i]))
}
colnames(scenarios)=c("nsim","n","m", "p","sigma","alpha","Prob_1","Prob_2","Prob_3")
scenarios=data.frame(scenarios)
###################
estimates_survival<- function(nsim,n,m,p,sigma,alpha,C,beta, lambda0,beta0){
coef_true_s<-matrix(0,nrow = nsim, ncol = p)
coef_naive_s<- matrix(0,nrow = nsim, ncol = p)
converge_naive <- vector()
coef_w_sum1_s<- matrix(0,nrow = nsim, ncol = p)
converge_w_sum1 <- vector()
coef_w_sum2_s<- matrix(0,nrow = nsim, ncol = p)
converge_w_sum2 <- vector()
coef_estimate_s <- matrix(0,nrow = nsim, ncol = p)
converge_estimate<- vector()
for (i in 1:nsim){
surv_data =Generate_data(m,n,beta)
g_naive <- doOne2d_equat_estimat(n,m,C,beta,surv_data)
coef_naive_s[i,] <- g_naive$coef_naive2
converge_naive[i] <- g_naive$converge_naive2
g_sum1 <- doOne2d_w_sum1 (n,m,surv_data,C)
coef_w_sum1_s[i,] <- g_sum1$coef_w_sum1
converge_w_sum1[i] <- g_sum1$converge_w_sum1
g_sum2 <- doOne2d_w_sum2 (n,m,surv_data,C)
coef_w_sum2_s[i,] <- g_sum2$coef_w_sum2
converge_w_sum2[i] <- g_sum2$converge_w_sum2
g_estim <- doOne2d_estimate (n,m,C,beta0,lambda0,surv_data)
coef_estimate_s [i,] <- g_estim$coef_estimate
converge_estimate [i] <- as.numeric (g_estim$converge_estimate)
coef_true_s[i,] <- g_estim$coef_true
}
return(list( coef_true_s1=coef_true_s[,1],coef_true_s2=coef_true_s[,2],
coef_naive_s1=coef_naive_s[,1], coef_naive_s2=coef_naive_s[,2], coef_w_sum1_s1=coef_w_sum1_s[,1],coef_w_sum1_s2=coef_w_sum1_s[,2],
coef_w_sum2_s1=coef_w_sum2_s[,1], coef_w_sum2_s2=coef_w_sum2_s[,2],
coef_estimate_s1=coef_estimate_s[,1],coef_estimate_s2=coef_estimate_s[,2],converge_naive=converge_naive, converge_w_sum1=converge_w_sum1,
converge_w_sum2=converge_w_sum2,converge_estimate= converge_estimate))  }
######################################
#results
set.seed(23)
for (i in (1:nrow(scenarios))){
nsim_sample=scenarios[i,1]
n_sample=scenarios[i,2]
m_sample=scenarios[i,3]
p_sample=scenarios[i,4]
sigma_sample=scenarios[i,5]
alpha_sample=scenarios[i,6]
C=vector()
C[1]=scenarios[i,7]
C[2]=scenarios[i,8]
C[3]=scenarios[i,9]
results_sample<- estimates_survival(nsim=nsim_sample,n=n_sample,m=m_sample,p=p_sample,sigma=sigma_sample,alpha=alpha_sample,C=C, beta, lambda0, beta0)
#boxplot(results_sample)
}
####################
View(results_sample)
View(results_sample)
results_sample[["coef_true_s1"]]
results_sample[["coef_true_s2"]]
results_sample=NULL
i=1
set.seed(23)
results_sample=NULL
nsim_sample=scenarios[i,1]
nsim_sample=scenarios[i,1]
n_sample=scenarios[i,2]
m_sample=scenarios[i,3]
p_sample=scenarios[i,4]
sigma_sample=scenarios[i,5]
alpha_sample=scenarios[i,6]
C=vector()
C[1]=scenarios[i,7]
C[2]=scenarios[i,8]
C[3]=scenarios[i,9]
results_sample[i]<- estimates_survival(nsim=nsim_sample,n=n_sample,m=m_sample,p=p_sample,sigma=sigma_sample,alpha=alpha_sample,C=C, beta, lambda0, beta0)
View(results_sample)
results_sample[[1]]
